# 2025年9月20日

## std::function、bind、lambda表达式的使用与理解

### function 的使用：

1. 理解 std::function 是一个函数包装器，可以存储、调用或复制任何可调用目标（普通函数、Lambda 表达式、函数对象、绑定表达式等）。
2. 能够正确地使用 std::function 声明函数类型变量，并赋值不同类型的可调用对象。

### bind 的使用：

1. 理解 std::bind 用于将可调用对象与其参数绑定在一起，生成一个新的可调用对象。
2. 能够正确使用 std::bind 绑定函数或成员函数的参数，包括占位符的使用。

### Lambda 表达式的使用：

1. 理解 Lambda 表达式是一种匿名函数对象，可以捕获其所在作用域中的变量。
2. 能够编写包含捕获列表、参数列表、函数体和返回类型的 Lambda 表达式。
3. 了解 Lambda 表达式的类型自动推导机制以及如何在不同场景下使用。

在C++中，有了std::function，就可以基本弃用之前的函数指针了，尝试理解模板方法设计模式，并引入std::function在其中。

## shared_ptr、unique_ptr的理解与使用

### 基本概念理解：

1. 理解 std::shared_ptr、std::weak_ptr 和 std::unique_ptr 是 C++11 引入的智能指针，用于自动管理动态分配的内存，防止内存泄漏。
2. 理解 shared_ptr 允许多个指针共享同一个对象，通过内部计数器（控制块）自动管理对象的生命周期。
3. 理解 unique_ptr 独占其指向的对象，确保同一时间内只有一个 unique_ptr 指向给定对象，当 unique_ptr 被销毁或重置时，其所指向的对象也会被销毁。
4. 理解 weak_ptr 是一种不拥有其所指向对象的智能指针，用于解决 shared_ptr 循环引用的问题，但不参与对象的生命周期管理。

### 智能指针的使用：

1. 能够正确地创建、赋值、传递和销毁 shared_ptr、unique_ptr 和 weak_ptr。
2. 理解并能够使用 std::make_shared、std::make_unique（C++14及以上）等工厂函数来创建智能指针。
3. 理解 weak_ptr 如何与 shared_ptr 一起工作以打破循环引用。

### 内存管理和异常安全：

1. 理解智能指针如何帮助实现异常安全的资源管理。

2. 理解在异常发生时，智能指针如何确保资源的正确释放。

   RAII，将资源的生命周期和对象绑定在一起，依赖于离开作用域自动销毁对象，从而调用智能指针的析构函数，然后delete资源。

3. 理解shared_ptr和unique_ptr的原理。

   shared_ptr通过类中两个成员变量，引用计数块和指向资源的指针，引用计数块用来计数当前资源被多少智能指针共享，每多一个共享的指针就加一计数器，每少一个就减一计数器，当计数器为0时，释放资源。

   unique_ptr和shared_ptr大致一样，没有计数器，并且删除了拷贝构造和拷贝赋值，达到独占资源的效果。

4. 为什么unique_ptr可以做到独占？

   删除了拷贝构造和拷贝赋值函数。

5. shared_ptr的引用计数什么时候+1，什么时候-1？

   +1情况：拷贝、赋值、函数参数传递或是从weak_ptr升级过来。

   -1情况：析构、主动reset或者管理新的资源时，原先管理的资源的共享指针计数块会-1。

6. 为什么要使用make_shared构造shared_ptr？有什么优势吗？

   1. 异常安全

      ```C++
      void processWidget(std::shared_ptr<Widget> spw, int priority);
      
      // 调用方式：使用 new
      processWidget(std::shared_ptr<Widget>(new Widget), computePriority()); // 有风险！
      
      // 调用方式：使用 make_shared
      processWidget(std::make_shared<Widget>(), computePriority()); // 安全！
      ```

      C++标准**没有规定函数参数的计算顺序**。编译器可能按以下顺序执行：

      1. `new Widget` (分配内存)
      2. `computePriority()` (可能抛出异常!)
      3. `std::shared_ptr<Widget>(...)` (构造智能指针，接管内存)

      如果在第2步 `computePriority()` 抛出了异常，那么第1步中已经分配的 `Widget` 对象的内存就**泄漏了**，因为它还没有被 `shared_ptr` 接管（RAII守卫尚未就位）。

      **`make_shared` 如何解决？**
      `std::make_shared<Widget>()` 是一个**单一的、完整的操作**：它一次性分配内存并构造对象，然后直接返回一个构造好的 `shared_ptr`。不存在“内存已分配但智能指针未构造”的中间状态，因此绝对是异常安全的。

   2. 性能优化，具体参考下面两张图

      这是使用new
      ![format,webp](https://ucc.alicdn.com/tt5afaowkormc/developer-article321323/20241017/328fcbda3b704e969ad3b516abd2ebbc.png)
      这是使用make_shared
      ![format,webp](https://ucc.alicdn.com/tt5afaowkormc/developer-article321323/20241017/3f4f3b92138847a2b32e5e4841a2ae46.png)

   3. 代码清晰简洁。

      **那么，什么时候不能使用 `make_shared`？**

      尽管优势巨大，但在少数特定场景下，你需要直接使用 `new`：

      1. **需要自定义删除器（Deleter）时**
         `make_shared` 无法指定自定义删除器。如果你管理的不是普通 `new` 分配的内存（例如，来自内存池、需要调用 `fclose` 关闭的 `FILE*` 等），你必须直接构造 `shared_ptr`。

         

         ```c++
         // make_shared 无法做到
         std::shared_ptr<FILE> filePtr(fopen("data.txt", "r"), fclose);
         ```

      2. **需要大括号初始化列表时**
         由于函数模板参数推导的语法限制，如果你需要向构造函数传递一个 `std::initializer_list`，使用 `make_shared` 会比较别扭，有时需要多包一层大括号。

         ```C++
         // 直接构造
         auto sp1 = std::shared_ptr<std::vector<int>>(new std::vector<int>{1, 2, 3, 4});
         
         // make_shared 需要额外的大括号
         auto sp2 = std::make_shared<std::vector<int>>(std::initializer_list<int>{1, 2, 3, 4});
         // 或者
         auto sp3 = std::make_shared<std::vector<int>>( (std::initializer_list<int>{1, 2, 3, 4}) );
         ```

      3. **对象内存生命周期特殊管理时（较少见）**

         - **`make_shared` 将对象和控制块捆绑在一起**，这意味着即使所有 `shared_ptr` 析构了（use_count=0），对象内存已经被销毁，但**控制块占用的内存必须等到所有 `weak_ptr` 也析构后才会被释放**（因为弱引用计数还存在）。
         - 如果你直接使用 `new`，对象内存和控制块内存是分开的。当 use_count=0 时，对象内存会立即被释放，控制块内存则会等待弱引用计数归零再释放。
         - 如果你的对象非常大，并且你希望在其引用计数归零后**立刻释放其内存**，而不是等待所有 `weak_ptr` 离开，那么直接使用 `new` 会更有优势。但这属于非常特殊的优化场景。

      ### 总结与建议

      | 特性             | `std::make_shared`                | 直接使用 `new`     |
      | :--------------- | :-------------------------------- | :----------------- |
      | **异常安全**     | **是**                            | **否**（有风险）   |
      | **性能**         | **高**（一次分配）                | **低**（两次分配） |
      | **代码简洁性**   | **高**（使用 `auto`，无类型重复） | **低**             |
      | **自定义删除器** | 不支持                            | 支持               |
      | **控制内存释放** | 对象和控制块生命周期绑定          | 可分离             |

      **最佳实践：**
      **默认情况下，总是优先使用 `std::make_shared` 来创建 `shared_ptr`。** 除非你遇到了上述的例外情况（需要自定义删除器、特殊的初始化列表或极端的内存生命周期控制），否则 `make_shared` 在安全性、性能和代码风格上都是更优的选择。对于 `std::unique_ptr`，同理应优先使用 `std::make_unique` (C++14引入)。

7. weak_ptr的原理？为什么weak_ptr可以判断shared_ptr是否有效？



力扣：[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* slow = nullptr;
        ListNode* fast = head;
        while (fast) {
            ListNode* next = fast->next;
            fast->next = slow;
            slow = fast;
            fast = next;
        }
        return slow;
    }
};
```

​	方法一：迭代法	

​	首先，迭代法是最容易想到的，就是依次取下链表节点，然后修改指向。具体操作步骤如下：创建一个用于记录反转链表表头的指针slow，创建一个用于遍历链表节点的指针fast，从head开始，然后，一直循环到fast遍历指针到链表尾。循环体中开始进行反转，首先创建一个记录fast下一步位置的指针，然后将fast当前节点的next指向slow，因为slow需要一直在反转链表的头部，所以先修改slow的位置，并且此时fast正好指向反转链表头，有记录，不然等fast跑到链表头去后，就无法获取反转链表头了，最后将下一个位置给到fast，然后循环直到结束。

​	方法二：递归法

​	可以通过递归调用时的栈结构来直接获取链表靠末尾的节点，然后在归的过程中，反向遍历链表，以实现反转

```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //递的终止条件，
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);//一直递到反转链表的头部，也就是原链表的尾
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

方法一：迭代法

​	首先最容易想到的就是遍历链表，使用一快一慢两个指针两两交换，具体思路如下，首先进行一次简单的判断，链表元素要是少于2个，就直接返回了，不需要交换。然后就是创建一快一慢两个指针分别从`head`和`head->next`开始，这里还需要创建一个用于记录交换好的链表的尾指针，不然交换过后的链表会和原链表失去联系。因为`slow`在前，`fast`在后，交换过后`fast`节点成了头节点，所以直接让`head`等于`fast`。

​	后面开始循环遍历链表，因为交换需要两个节点，所以当新的快慢指针有一个是`nullptr`时，此时单元素或是没有元素，说明已经遍历到链表尾了，循环终止。然后循环体内和之前反转链表迭代法一个思路，先记录一下未交换的链表头，然后交换`slow`和`fast`，交换好之后，记录交换好链表的尾节点，以便后续连接，如果是第一次交换，则让`prev`指向`slow`，然后开始新的交换，`slow`移动到`next`节点，此时`fast`需要判断一下`slow`的情况，避免访问空指针。最后返回链表。

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* slow = head;
        ListNode* fast = head->next;
        ListNode* prev = nullptr; 
        head = fast;

        while (slow != nullptr && fast != nullptr) {
            ListNode* next = fast->next;

            fast->next = slow;
            slow->next = next;

            if (prev != nullptr) {
                prev->next = fast;
            }

            prev = slow;
            slow = next;
            fast = (slow != nullptr ? slow->next : nullptr);
        }
        return head;
    }
};
```

方法二：递归法

​	递归终止条件，链表单节点或空节点，新的链表头是`head->next`，然后开始递进到链表尾，回归过程开始交换，

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->next = head;
        return newHead;
    }
};
```

[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

方法一：双指针迭代法

​	双方都走两遍链表，如果链表相交，必定在交点处相遇，A先遍历自己的链表，B也先遍历自己的链表，当某一方走完链表之后，跳到对方的链表开始遍历。只要A和B没有指向同一个节点就一直遍历，相交时，返回空。

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* ptr_a=headA;
        ListNode* ptr_b=headB;
        while(ptr_a!=ptr_b){
            ptr_a= ptr_a!=NULL ? ptr_a->next :headB;
            ptr_b= ptr_b!=NULL ? ptr_b->next : headA;
        }
        return ptr_a;
    }
};
```

方法二：哈希集合

​	先遍历A链表，把每个节点都放入集合中，然后开始遍历B链表，检查在集合中是否存在，若存在则链表有相交点，直接返回节点，若遍历完，则说明没有相交点，返回空指针。

```C++
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        std::unordered_set<ListNode*> un_set;
        ListNode* temp=headA;
        while(temp!=nullptr){
            un_set.insert(temp);
            temp=temp->next;
        }
        temp=headB;
        while(temp!=nullptr){
            if(un_set.find(temp)!=un_set.end()){
                return temp;
            }
            temp=temp->next;
        }
        return nullptr;
    }
};
```

