# 2025年9月14日

## 算法：倒数第k个节点

题目描述：给定一个头节点为 `head` 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 `cnt` 个训练项目编号。

**示例 1：**

```
输入：head = [2,4,7,8], cnt = 1
输出：8
```

代码解答：

解答一：首先最容易想到的就是先获取出链表节点个数`n`，然后遍历`n-cnt`次，到达倒数第`cnt`个节点

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* trainingPlan(ListNode* head, int cnt) {
        int n=0;
        ListNode* node=nullptr;
        //先遍历一边，记录有多少个节点
        for(node=head;node;node=node->next){
            n++;
        }
        node=head;
        //第二次遍历找到倒数第cnt个节点
        for(int i=0;i<n-cnt;i++){
            node=node->next;
        }

        return node;
    }
};
```

解法二：快慢双指针，让一个快指针`fast`先走`cnt`个节点，然后快慢指针一起向后移动，当快指针`fast`到达链表末尾时，慢指针`slow`也就刚好到达倒数第`cnt`个节点。

```C++
class Solution {
public:
    ListNode* trainingPlan(ListNode* head, int cnt) {
        ListNode* fast=head;
        ListNode* slow=head;
        //需要对链表长度小cnt做判断
        while(fast && cnt > 0){
            fast = fast->next;
            cnt--;
        }
        while (fast) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 操作符重载

### 基本概念理解

1. 理解操作符重载的概念，即允许用户为自定义类型（如类）的实例定义操作符的行为。

2. 了解哪些操作符可以被重载（如算术操作符、比较操作符、赋值操作符等），以及哪些操作符不能被重载（如.、.*、::、sizeof、typeid等）。

3. 理解操作符重载函数的声明方式，包括返回类型、函数名和参数列表。

   ```C++
   返回类型 operator 操作符(参数){
       
   }
   ```

   

### 操作符重载的语义

1. 确保重载的操作符保持其原有的语义，即操作的行为和预期结果应与内置类型的相应操作一致。

2. 理解并处理操作符重载可能引入的复杂性和潜在问题，如运算符优先级和结合性。
   比如：`++`, `--` (递增递减运算符):
   - **语义：** 前缀形式（`++obj`）应“先增减，后返回值”；后缀形式（`obj++`）应“先返回原值，后增减”。后缀版本通常接受一个 `int` 形参以作区分。
     还有其他情况，略。
   
     **总结：** 在重载任何操作符之前，先问自己：“对于内置类型，这个操作符意味着什么？” 然后让你的重载版本尽可能地模拟这种行为。

1. 左值右值不同的类型可以构成重载吗？

   可以，参考移动构造函数和移动赋值函数

2. 是否加const可以构成重载吗？

   可以，最常见就是修饰this指针，用于限制成员函数的修改数据权限。

## 继承 多继承 多态

### 继承

1. 理解继承的基本概念，即子类（派生类）可以继承父类（基类）的属性和方法。

2. 掌握单继承和多继承的语法和用法。

3. 理解继承中的访问控制，包括public、protected、private成员在继承中的可见性。

4. 了解构造函数和析构函数在继承中的调用顺序。

   先构造基类后构造子类，先析构子类后析构基类

### 多继承

1. 理解多继承的概念，即一个类可以继承自多个基类。

2. 掌握多继承中的菱形继承（钻石继承）问题及其解决方法（如虚拟继承）。

   中间类继承基类时使用虚继承

3. 理解多继承中构造函数和析构函数的调用顺序。

### 多态

1. 理解多态的基本概念，即允许不同类的对象对同一消息作出响应。

2. 掌握通过虚函数实现多态的方法。

   重写虚函数

3. 理解虚析构函数的作用和必要性。

   虚析构函数的主要作用是：当通过基类指针删除一个指向派生类对象的指针时，能够确保调用正确的（派生类的）析构函数，从而进行完整的资源清理，避免内存泄漏。

   它的**必要性**体现在面向对象编程的多态性中。如果没有虚析构函数，使用基类指针删除派生类对象会导致**未定义行为**（通常是派生类的析构函数不被调用，从而引发资源泄漏）。

4. 了解纯虚函数和抽象类的概念。

### 附加

1. 多态的原理如何？为什么可以实现多态？

2. 无继承场景、单继承场景、多继承场景下，对象布局如何？

3. 构造函数可以为虚函数吗？

   不可以，虚函数依赖于虚函数表指针，依赖于构造，这就造成了，没有虚函数表指针，那你构造对象啊，但是构造函数又是虚函数的套娃需求。

4. 析构函数可以为虚函数吗？

   可以，而且最好是虚函数。

5. 理解final关键字的作用

   **阻止类被继承**（用于类名后）。**阻止虚函数在派生类中被重写**（用于函数声明的末尾）

6. 理解override关键字的作用

   明显地、强制地表示重写基类虚函数
