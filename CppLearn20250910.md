# 2025年9月10日

## 数组的使用与理解

1. 基本声明与初始化：能够正确声明并初始化一维和多维数组。

   ```c++
   //声明一维数组,赋值就是初始化
   int nums[5]={0};
   //多维,比如二维
   int nums[3][3]
   ```

2. 遍历：能够使用循环结构（如for、while）遍历数组并处理每个元素。

   ```C++
   //for循环遍历
   for(int i=0;i<nums.size();++i){
     nums[i];
   }
   //while循环遍历
   int i=0;
   while(i<nums.size()){
     nums[i];
     ++i;
   }
   ```

3. 元素访问：能够正确访问并修改数组中的元素。

   访问参考遍历，修改看具体操作。

4. 数组操作：能够进行基本的数组操作，如计算数组长度（对于静态数组，了解它是编译时确定的）。注意，C++标准数组不支持动态改变大小或直接在数组中插入/删除元素，但需要了解这些操作的概念和在其他容器（如vector）中的应用。

   

5. 排序：了解并能实现至少一种排序算法（如冒泡排序、选择排序、插入排序等）对数组进行排序。

   ```C++
   n为元素个数
   //冒泡排序，每次比较相邻一对数据，不符合顺序（比如从小到大），就将大一点的值向后交换，最后会让最大值在数组最后面，因为有n个元素，所以需要一个外层循环对每个数做一次循环
   for(int i=0;i<n-1;++i){
     for(int j=0;j<n-1-i;++j){
       if(nums[j]>nums[j+1]){
         int temp=nums[j];
         nums[j]=nums[j+1];
         nums[j+1]=temp;
       }
     }
   }
   
   //选择排序，每次遍历未排序部分，寻找最小值或最大值，然后交换到排序部分的最后
   for(int i=0;i<n-1;++i){
     //需要一个变量记录最小值的索引
     int min_idx=i;
     for(int j=i+1;j<n;++j){
       if(nums[j]<nums[min_idx]){
         min_idx=j;
       }
     }
     //找完最小值后，就行交换
     int temp=nums[i];
     nums[i]=nums[min_idx];
     nums[min_idx]=temp;
   }
   
   //插入排序，和选择排序差不多，但是遍历未排序部分时，直接选择未排序部分第一个元素选择插入到已经排好序的部分的合适位置
   for(int i=1;i<n;++i){
     int key=nums[i-1];
     int j=i-1;
     // 直接比较排序好序列的最后一个值，将比key大的元素向后移动，然后反复
     while (j >= 0 && nums[j] > key) {
       nums[j + 1] = nums[j];
       j--;
     }
     //直到没有值比比较值小时，或者比较值已经小于nums[j]时，放到后面一位nums[j+1]
     nums[j + 1] = key;
   }
   
   //希尔排序，插入排序的改进版，将原序列分成几组分别插入排序，最后再整体插入排序
   {8,7,6,5,4,3,2,1}->分成两部分四组{8,7,6,5|4,3,2,1}->然后遍历4次比较每组对应的元素，(8,4),(7,3),(6,2),(5,1)->
   {4,3,2,1,8,7,6,5}->分成四部分两组{4,3|2,1|8,7|6,5}->这里2和4比较{2,3|4,1|8,7|6,5}->这里3和1比较{2,1|4,3|8,7|6,5}->这里4和8比较{2,1|4,3|8,7|6,5}->这里3和7比较{2,1|4,3|8,7|6,5}->这里8和6比较{2,1|4,3|6,7|8,5}->这里7和5比较{2,1|4,3|6,5|8,7}->最后分成一部分一组，整体插入排序{1,2,3,4,5,6,7,8}
   // 初始增量设为数组长度的一半，然后逐步缩小
       for (int gap = n / 2; gap > 0; gap /= 2) {
           // 从第gap个元素开始，对每个分组进行插入排序
           for (int i = gap; i < n; i++) {
               int temp = arr[i]; // 当前需要插入的元素
               int j;
               
               // 对当前分组进行插入排序
               for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                   arr[j] = arr[j - gap]; // 将较大的元素后移
               }
               arr[j] = temp; // 插入到正确位置
           }
       }
   
   //归并排序，分治策略，将数组分成两部分，分别排序，然后合并，通常递归分治直到每部分只剩一个元素，然后在合并时进行两边元素的比较
   void mergeSort(int nums[],int lerf,int right){
     //区间为1，单元素必定有序，递归调用的返回接口
     if(left >= right){
       return;
     }
     //找出中间元素索引
     int mid=left + (left + right) / 2;
     // 递归排序左右两半
       mergeSort(arr, left, mid);
       mergeSort(arr, mid + 1, right);
     //已经分到不能分了，开始排序合并
     
     int temp[right - left + 1];//创建一个能包含左右两边元素的临时数组
     //用三个索引来移动合并
     int i=left,int j=mid+1;int k=0;
     
     //两边都没有遍历的完的情况下,判断两边的元素谁小，就放入谁，然后向后移后
     while(i<=mid && j<=right){
       if(nums[i]<=nums[j]){
         temp[k]=nums[i];
         k++;
         i++;
       }else{
         temp[k]=nums[j];
         k++;
         j++;
       }
     }
     //此时有一边已经是遍历完了的情况,假设右边先放入完成，则复制左边部分剩余元素
     while(i<=mid){
       temp[k]=nums[i];
       k++;
       i++;
     }
     while(j<=right){
       temp[k]=nums[j];
       k++;
       j++;
     }
     
     //最后拷贝回原数组
     for(int x=0;x<(sizeof(temp)/sizeof(temp[0]));++x){
       nums[left+x]=temp[x];
     }
   }
   
   //快速排序,分治策略，选择一个基准元素，将数组分为两部分，左边都小于基准，右边都大于基准，然后递归排序。
   void quickSort(int nums[],int left,int,right){
     //区间为1，单元素必定有序，递归调用的返回接口
     if(left>=right){
       return;
     }
     
     int i=left;
     int j=right;
     int mid=(left+right)/2;
     int p=nums[mid];//基准值记录
     
     while(i<=j){
       while(nums[i]<p){
         ++i;
       }
       while(nums[j]>p){
         --j;
       }
       //当同时在两边找到大于基准值和小于基准值的数时，交换两边，且满足i在左侧，j在右侧
       if(i<=j){
         int temp=nums[i];
         nums[i]=nums[j];
         nums[j]=temp;
         i++;
         j--;
       }
     }
     //对两边递归调用
     if(i<right){
       quickSort(nums,i,right);
     }
     if(j>left){
       quickSort(nums,left,j);
     }
   }
   ```

   1. 函数参数形参为数组类型时，通过sizeof打印其数组的大小，验证数组在函数传参时是否已退化为指针类型。

      ```C++
      void number(int nums[]){
        std::cout<<sizeof(nums);
      }
      int nums[]={1,2,3};
      number(nums);
      //控制台输出8，说明nums是一个指针
      ```

   2. 尝试使用更多算法对数组进行排序，并打印排序后的数组。

      

   3. 思考函数中传递二维数组时，除了传递指针，还需要传递哪些参数，才可以完整覆盖二维数组的详细信息。

      ```C++
      还需要行数和列数，传入的指针，但是内存中是顺序存储,比如：
        int nums[2][4]={
        {1,2,3,4},
        {5,6,7,8}};
      实际内存中nums={1,2,3,4,5,6,7,8};
      ```

## 指针的理解

   1. 基本概念理解：理解指针是变量，用于存储内存地址，并理解指针与所指向数据类型的关联。

   2. 指针类型与大小：了解指针的类型决定了其指向数据的大小和解引用的权限，以及指针本身在32位和64位平台上的大小。

      ```c++
      int* p;//指向一个整数的地址
      32位系统的指针是4byte=32bit，64位系统的指针是8byte=64bit
      ```

   3. 指针的赋值与初始化：掌握如何正确初始化指针，避免野指针的出现，以及指针赋值时的类型一致性要求。

      ```C++
      int a=6;
      int *p=&a;//初始化，int指针指向int类型数据，指针和被指向的数据类型不匹配不太好
      ```

      

   4. 指针的运算：理解指针的加减运算（仅限于同类型指针或指向同一数组元素的指针），以及指针比较运算的意义。

      ```C++
      int nums[5]={0};
      int* p=nums;//等价nums[0]
      int p1=p++;//后移一个int的大小，也就是nums[1]的位置;
      p1 != p;//判断两个指针是否指向同一个地址
      ```

      

   5. 指针与数组：掌握通过指针访问数组元素的方法，理解数组名作为指针的特殊性质。

      ```C++
      int nums[3]={0};
      int* p=nums;
      int number=*p;//解引用符号*用于获取地址内的数据
      ```

      

   6. 指针与函数：理解指针作为函数参数和返回值的使用场景，以及如何通过指针在函数间传递和修改数据。

      ```C++
      // 作为函数参数时：
      // 1.直接修改外部参数，因为是直接访问的地址
      // 2.传递数组
      // 3.传递结构体，避免拷贝，虽然一般都是引用传参
      // 作为返回值时：
      // 1.返回动态分配的内存
      // 2.返回静态或全局变量的数据的指针，
      // 适合作为指针参数时的场景：
      // 1.需要修改多个返回值
      // 2.操作大型数据结构
      // 3.实现多态
      // 适合作为返回值的场景：
      // 1.工厂模式,返回不同的类型
      class Product {
      public:
          virtual void use() = 0;
          virtual ~Product() = default;
      };
      
      Product* createProduct(int type) {
          switch (type) {
              case 1: return new ConcreteProductA();
              case 2: return new ConcreteProductB();
              default: return nullptr;
          }
      }
      // 2.资源管理
      FILE* openFile(const char* filename, const char* mode) {
          FILE* file = fopen(filename, mode);
          if (!file) {
              std::cerr << "无法打开文件: " << filename << std::endl;
          }
          return file;
      }
      // 3.查找和返回引用
      Student* findStudent(Student* students, int count, int id) {
          for (int i = 0; i < count; i++) {
              if (students[i].getId() == id) {
                  return &students[i];
              }
          }
          return nullptr;
      }
      
      ```

      

   7. 指针的安全使用：了解避免野指针、内存泄漏等指针相关错误的方法和技巧。

      ```C++
      // 野指针是指向无效内存地址的指针，通常由以下情况产生：
      // 1.指针未初始化
      // 2.指针指向已释放的内存
      // 3.指针越界访问
      		// 情况1：未初始化的指针
          int* uninitializedPtr;
          // std::cout << *uninitializedPtr; // 未定义行为！
          
          // 情况2：指向已释放的内存
          int* ptr = new int(42);
          delete ptr;
          // std::cout << *ptr; // 野指针！ptr现在指向已释放的内存
          
          // 情况3：指向局部变量（函数返回后）
          int* localPtr = nullptr;
          {
              int localVar = 100;
              localPtr = &localVar; // 危险：localVar即将被销毁
          }
          // std::cout << *localPtr; // 野指针！localVar已销毁
      // 针对上面三点，避免野指针可以分为1）创建就初始化；2）释放后立即置空；3）RAII的思想
      
      ```

## malloc、realloc、free的使用与理解

1. 理解如何使用malloc动态分配空间，并检查返回值确定内存是否分配成功

   ```C++
   void* malloc(size_t size);//size是字节的大小，创建成功返回一个非空指针；创建失败返回一个空指针
   ```

   

2. 理解如何使用realloc调整内存大小

   ```C++
   void* realloc(void* ptr,size_t size);//ptr是需要扩容的空间地址，size是新内存块的字节大小，创建成功返回一个新的空间指针；创建失败返回一个空指针，原空间地址不变
   ```

   

3. 理解如何使用free用于释放之前通过malloc或realloc分配的内存空间。

   ```C++
   void free(void* ptr);//传入需要释放空间的指针
   ```

   

1. 尝试研究下，为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢？会不会多释放一些内存或者少释放了一些内存？

   ```C++
   /*这是因为创建的空间不只有传入的size这么大，在地址左移的方向上会有一个包含这块地址空间一些参数的内存块，在free时，会到前一部分元数据区获取这个内存空间的大小，然后free就能完全释放这块内存空间了。
   题外话，现代内存分配器有边界保护，可能是这样的
   [保护字节][元数据][用户数据][保护字节]
   */
   ```

   

2. malloc更底层的原理是什么？一次malloc底层都经历了什么？

   等待以后有空深入研究

   <a id="destination"></a>

3.  堆内存和栈内存的区别？

   | 特性       | 堆内存                     | 栈内存                         |
   | ---------- | -------------------------- | ------------------------------ |
   | 管理方式   | 编译器自动管理（LIFO）     | 程序员手动管理（new/delete）   |
   | 分配速度   | 极快（移动指针             | 较慢（可能需要系统调用）       |
   | 内存碎片   | 无                         | 可能产生                       |
   | 缓存局部性 | 优（连续分配）             | 差（分散分配）                 |
   | 线程安全   | 天然安全（线程独立）       | 需要同步机制（如锁）           |
   | 容量       | 固定且较小（易溢出）       | 动态扩展（受系统内存限制）     |
   | 适用场景   | 局部变量、小对象、短期数据 | 大对象、动态数据结构、长期数据 |

4. 栈数组下标越界访问会发生什么？

   ```C++
   //1.崩溃。情况1:访问受保护的内存；情况2:破坏栈帧结构
   //情况1:
   int nums[5]={0};
   // 访问栈下方的保护页（通常有guard page）
   int value = nums[-1000]; // 可能立即段错误
       
   // 访问栈上方的保护区域
   int value2 = nums[1000]; // 可能立即段错误
   //情况2:
   void functionA() {
       int array[3] = {1, 2, 3};
       array[5] = 0xdeadbeef; // 覆盖返回地址
       // 函数返回时跳转到非法地址，导致崩溃
   }
   
   void functionB() {
       int a = 10, b = 20;
       int array[2] = {1, 2};
       array[3] = 100; // 可能覆盖局部变量b
       std::cout << b; // 输出可能变成100
   }
   //2.数据破坏。情况1:覆盖相邻局部变量；情况2:破坏函数调用栈
   //情况1:
   void silentDataCorruption() {
       int important_value = 42;
       int passwords[3] = {111, 222, 333};
       int another_value = 100;
       
       // 越界写入，破坏相邻变量
       passwords[4] = 999; // 可能修改important_value或another_value
       
       std::cout << "重要值: " << important_value << std::endl; // 可能不是42了
       std::cout << "另一个值: " << another_value << std::endl; // 可能不是100了
   }
   //情况2:
   void victimFunction(int x) {
       std::cout << "参数x: " << x << std::endl;
   }
   
   void attackerFunction() {
       int buffer[2] = {1, 2};
       int local_var = 50;
       
       // 越界访问可能修改调用者的栈帧
       buffer[3] = 666; // 可能修改victimFunction的参数x
       
       victimFunction(100); // 可能输出"参数x: 666"
   }
   //3.安全漏洞。情况1:栈溢出攻击基础（栈缓冲区溢出攻击）情况2:信息泄露
   //情况1:
   void vulnerableFunction(const char* input) {
       char buffer[64]; // 固定大小的栈缓冲区
       
       // 危险的字符串操作
       strcpy(buffer, input); // 如果input超过63字符，就会越界
       
       // 攻击者可以精心构造input来覆盖返回地址
   }
   
   void demoExploit() {
       char exploit[100];
       memset(exploit, 'A', 100);
       // 在特定位置插入恶意代码地址
       *(void**)(exploit + 72) = (void*)malicious_code;
       
       vulnerableFunction(exploit); // 触发漏洞
   }
   ```

5. 什么是栈溢出？

   栈溢出是指，向栈内存写入数据时，写入了超过分配的内存大小的情况，使用了超过的、不受监管的、相邻的内存空间

6. 了解常见的栈溢出手段

   攻击核心原理：

   栈的内存布局是攻击的基础。当一个函数被调用时，栈上会压入（大致顺序如下）：

   1. **函数参数**
   2. **返回地址 (Return Address)**：这是攻击的主要目标。它告诉函数执行完毕后应该回到哪里继续执行。
   3. **旧的栈帧指针 (Old EBP/RBP)**
   4. **局部变量**

```C++
#include <iostream>
#include <cstring>

void vulnerable_function(const char* input) {
    char buffer[64]; // 在栈上分配一个64字节的缓冲区
    strcpy(buffer, input); // 🚨 危险！如果input超过64字节，将发生溢出
    std::cout << "Received: " << buffer << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc > 1) {
        vulnerable_function(argv[1](@ref); // 攻击者通过命令行参数传入超长字符串
    }
    return 0;
}
```

## 内存布局（堆 vs 栈）

1. 基本概念理解：

理解栈内存（Stack Memory）是自动分配和释放的，通常用于存储局部变量、函数参数等。

理解堆内存（Heap Memory）是动态分配和释放的，通过malloc、calloc、realloc等函数分配，通过free释放。

理解栈内存和堆内存在内存管理、作用域、生命周期等方面的区别。

参考：[堆内存和栈内存的区别](#destination)

2. 堆内存的使用：

能够使用malloc、calloc、realloc等函数在堆上动态分配内存。

能够检查这些函数的返回值以确保内存分配成功。

能够在不再需要时，使用free函数释放堆内存，避免内存泄漏。

3. 栈内存与堆内存的对比：

能够通过编程实践展示栈内存和堆内存的不同使用场景和特性。

参考：[堆内存和栈内存的区别](#destination)

## 函数指针 指针函数







