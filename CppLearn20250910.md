# 2025年9月10日

由于前几天没有想写日志，所以全都放在9月10日这一天的文档内



## 数组的使用与理解

1. 基本声明与初始化：能够正确声明并初始化一维和多维数组。

   ```c++
   //声明一维数组,赋值就是初始化
   int nums[5]={0};
   //多维,比如二维
   int nums[3][3]
   ```

2. 遍历：能够使用循环结构（如for、while）遍历数组并处理每个元素。

   ```C++
   //for循环遍历
   for(int i=0;i<nums.size();++i){
     nums[i];
   }
   //while循环遍历
   int i=0;
   while(i<nums.size()){
     nums[i];
     ++i;
   }
   ```

3. 元素访问：能够正确访问并修改数组中的元素。

   访问参考遍历，修改看具体操作。

4. 数组操作：能够进行基本的数组操作，如计算数组长度（对于静态数组，了解它是编译时确定的）。注意，C++标准数组不支持动态改变大小或直接在数组中插入/删除元素，但需要了解这些操作的概念和在其他容器（如vector）中的应用。

   

5. 排序：了解并能实现至少一种排序算法（如冒泡排序、选择排序、插入排序等）对数组进行排序。

   ```C++
   n为元素个数
   //冒泡排序，每次比较相邻一对数据，不符合顺序（比如从小到大），就将大一点的值向后交换，最后会让最大值在数组最后面，因为有n个元素，所以需要一个外层循环对每个数做一次循环
   for(int i=0;i<n-1;++i){
     for(int j=0;j<n-1-i;++j){
       if(nums[j]>nums[j+1]){
         int temp=nums[j];
         nums[j]=nums[j+1];
         nums[j+1]=temp;
       }
     }
   }
   
   //选择排序，每次遍历未排序部分，寻找最小值或最大值，然后交换到排序部分的最后
   for(int i=0;i<n-1;++i){
     //需要一个变量记录最小值的索引
     int min_idx=i;
     for(int j=i+1;j<n;++j){
       if(nums[j]<nums[min_idx]){
         min_idx=j;
       }
     }
     //找完最小值后，就行交换
     int temp=nums[i];
     nums[i]=nums[min_idx];
     nums[min_idx]=temp;
   }
   
   //插入排序，和选择排序差不多，但是遍历未排序部分时，直接选择未排序部分第一个元素选择插入到已经排好序的部分的合适位置
   for(int i=1;i<n;++i){
     int key=nums[i-1];
     int j=i-1;
     // 直接比较排序好序列的最后一个值，将比key大的元素向后移动，然后反复
     while (j >= 0 && nums[j] > key) {
       nums[j + 1] = nums[j];
       j--;
     }
     //直到没有值比比较值小时，或者比较值已经小于nums[j]时，放到后面一位nums[j+1]
     nums[j + 1] = key;
   }
   
   //希尔排序，插入排序的改进版，将原序列分成几组分别插入排序，最后再整体插入排序
   {8,7,6,5,4,3,2,1}->分成两部分四组{8,7,6,5|4,3,2,1}->然后遍历4次比较每组对应的元素，(8,4),(7,3),(6,2),(5,1)->
   {4,3,2,1,8,7,6,5}->分成四部分两组{4,3|2,1|8,7|6,5}->这里2和4比较{2,3|4,1|8,7|6,5}->这里3和1比较{2,1|4,3|8,7|6,5}->这里4和8比较{2,1|4,3|8,7|6,5}->这里3和7比较{2,1|4,3|8,7|6,5}->这里8和6比较{2,1|4,3|6,7|8,5}->这里7和5比较{2,1|4,3|6,5|8,7}->最后分成一部分一组，整体插入排序{1,2,3,4,5,6,7,8}
   // 初始增量设为数组长度的一半，然后逐步缩小
       for (int gap = n / 2; gap > 0; gap /= 2) {
           // 从第gap个元素开始，对每个分组进行插入排序
           for (int i = gap; i < n; i++) {
               int temp = arr[i]; // 当前需要插入的元素
               int j;
               
               // 对当前分组进行插入排序
               for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                   arr[j] = arr[j - gap]; // 将较大的元素后移
               }
               arr[j] = temp; // 插入到正确位置
           }
       }
   
   //归并排序，分治策略，将数组分成两部分，分别排序，然后合并，通常递归分治直到每部分只剩一个元素，然后在合并时进行两边元素的比较
   void mergeSort(int nums[],int lerf,int right){
     //区间为1，单元素必定有序，递归调用的返回接口
     if(left >= right){
       return;
     }
     //找出中间元素索引
     int mid=left + (left + right) / 2;
     // 递归排序左右两半
       mergeSort(arr, left, mid);
       mergeSort(arr, mid + 1, right);
     //已经分到不能分了，开始排序合并
     
     int temp[right - left + 1];//创建一个能包含左右两边元素的临时数组
     //用三个索引来移动合并
     int i=left,int j=mid+1;int k=0;
     
     //两边都没有遍历的完的情况下,判断两边的元素谁小，就放入谁，然后向后移后
     while(i<=mid && j<=right){
       if(nums[i]<=nums[j]){
         temp[k]=nums[i];
         k++;
         i++;
       }else{
         temp[k]=nums[j];
         k++;
         j++;
       }
     }
     //此时有一边已经是遍历完了的情况,假设右边先放入完成，则复制左边部分剩余元素
     while(i<=mid){
       temp[k]=nums[i];
       k++;
       i++;
     }
     while(j<=right){
       temp[k]=nums[j];
       k++;
       j++;
     }
     
     //最后拷贝回原数组
     for(int x=0;x<(sizeof(temp)/sizeof(temp[0]));++x){
       nums[left+x]=temp[x];
     }
   }
   
   //快速排序,分治策略，选择一个基准元素，将数组分为两部分，左边都小于基准，右边都大于基准，然后递归排序。
   void quickSort(int nums[],int left,int,right){
     //区间为1，单元素必定有序，递归调用的返回接口
     if(left>=right){
       return;
     }
     
     int i=left;
     int j=right;
     int mid=(left+right)/2;
     int p=nums[mid];//基准值记录
     
     while(i<=j){
       while(nums[i]<p){
         ++i;
       }
       while(nums[j]>p){
         --j;
       }
       //当同时在两边找到大于基准值和小于基准值的数时，交换两边，且满足i在左侧，j在右侧
       if(i<=j){
         int temp=nums[i];
         nums[i]=nums[j];
         nums[j]=temp;
         i++;
         j--;
       }
     }
     //对两边递归调用
     if(i<right){
       quickSort(nums,i,right);
     }
     if(j>left){
       quickSort(nums,left,j);
     }
   }
   ```

   1. 函数参数形参为数组类型时，通过sizeof打印其数组的大小，验证数组在函数传参时是否已退化为指针类型。

      ```C++
      void number(int nums[]){
        std::cout<<sizeof(nums);
      }
      int nums[]={1,2,3};
      number(nums);
      //控制台输出8，说明nums是一个指针
      ```

   2. 尝试使用更多算法对数组进行排序，并打印排序后的数组。

      

   3. 思考函数中传递二维数组时，除了传递指针，还需要传递哪些参数，才可以完整覆盖二维数组的详细信息。

      ```C++
      还需要行数和列数，传入的指针，但是内存中是顺序存储,比如：
        int nums[2][4]={
        {1,2,3,4},
        {5,6,7,8}};
      实际内存中nums={1,2,3,4,5,6,7,8};
      ```

## 指针的理解

   1. 基本概念理解：理解指针是变量，用于存储内存地址，并理解指针与所指向数据类型的关联。

   2. 指针类型与大小：了解指针的类型决定了其指向数据的大小和解引用的权限，以及指针本身在32位和64位平台上的大小。

      ```c++
      int* p;//指向一个整数的地址
      32位系统的指针是4byte=32bit，64位系统的指针是8byte=64bit
      ```

   3. 指针的赋值与初始化：掌握如何正确初始化指针，避免野指针的出现，以及指针赋值时的类型一致性要求。

      ```C++
      int a=6;
      int *p=&a;//初始化，int指针指向int类型数据，指针和被指向的数据类型不匹配不太好
      ```

      

   4. 指针的运算：理解指针的加减运算（仅限于同类型指针或指向同一数组元素的指针），以及指针比较运算的意义。

      ```C++
      int nums[5]={0};
      int* p=nums;//等价nums[0]
      int p1=p++;//后移一个int的大小，也就是nums[1]的位置;
      p1 != p;//判断两个指针是否指向同一个地址
      ```

      

   5. 指针与数组：掌握通过指针访问数组元素的方法，理解数组名作为指针的特殊性质。

      ```C++
      int nums[3]={0};
      int* p=nums;
      int number=*p;//解引用符号*用于获取地址内的数据
      ```

      

   6. 指针与函数：理解指针作为函数参数和返回值的使用场景，以及如何通过指针在函数间传递和修改数据。

      ```C++
      // 作为函数参数时：
      // 1.直接修改外部参数，因为是直接访问的地址
      // 2.传递数组
      // 3.传递结构体，避免拷贝，虽然一般都是引用传参
      // 作为返回值时：
      // 1.返回动态分配的内存
      // 2.返回静态或全局变量的数据的指针，
      // 适合作为指针参数时的场景：
      // 1.需要修改多个返回值
      // 2.操作大型数据结构
      // 3.实现多态
      // 适合作为返回值的场景：
      // 1.工厂模式,返回不同的类型
      class Product {
      public:
          virtual void use() = 0;
          virtual ~Product() = default;
      };
      
      Product* createProduct(int type) {
          switch (type) {
              case 1: return new ConcreteProductA();
              case 2: return new ConcreteProductB();
              default: return nullptr;
          }
      }
      // 2.资源管理
      FILE* openFile(const char* filename, const char* mode) {
          FILE* file = fopen(filename, mode);
          if (!file) {
              std::cerr << "无法打开文件: " << filename << std::endl;
          }
          return file;
      }
      // 3.查找和返回引用
      Student* findStudent(Student* students, int count, int id) {
          for (int i = 0; i < count; i++) {
              if (students[i].getId() == id) {
                  return &students[i];
              }
          }
          return nullptr;
      }
      
      ```

      

   7. 指针的安全使用：了解避免野指针、内存泄漏等指针相关错误的方法和技巧。

      ```C++
      // 野指针是指向无效内存地址的指针，通常由以下情况产生：
      // 1.指针未初始化
      // 2.指针指向已释放的内存
      // 3.指针越界访问
      		// 情况1：未初始化的指针
          int* uninitializedPtr;
          // std::cout << *uninitializedPtr; // 未定义行为！
          
          // 情况2：指向已释放的内存
          int* ptr = new int(42);
          delete ptr;
          // std::cout << *ptr; // 野指针！ptr现在指向已释放的内存
          
          // 情况3：指向局部变量（函数返回后）
          int* localPtr = nullptr;
          {
              int localVar = 100;
              localPtr = &localVar; // 危险：localVar即将被销毁
          }
          // std::cout << *localPtr; // 野指针！localVar已销毁
      // 针对上面三点，避免野指针可以分为1）创建就初始化；2）释放后立即置空；3）RAII的思想
      
      ```

## malloc、realloc、free的使用与理解

1. 理解如何使用malloc动态分配空间，并检查返回值确定内存是否分配成功

   ```C++
   void* malloc(size_t size);//size是字节的大小，创建成功返回一个非空指针；创建失败返回一个空指针
   ```

   

2. 理解如何使用realloc调整内存大小

   ```C++
   void* realloc(void* ptr,size_t size);//ptr是需要扩容的空间地址，size是新内存块的字节大小，创建成功返回一个新的空间指针；创建失败返回一个空指针，原空间地址不变
   ```

   

3. 理解如何使用free用于释放之前通过malloc或realloc分配的内存空间。

   ```C++
   void free(void* ptr);//传入需要释放空间的指针
   ```

   

1. 尝试研究下，为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢？会不会多释放一些内存或者少释放了一些内存？

   ```C++
   /*这是因为创建的空间不只有传入的size这么大，在地址左移的方向上会有一个包含这块地址空间一些参数的内存块，在free时，会到前一部分元数据区获取这个内存空间的大小，然后free就能完全释放这块内存空间了。
   题外话，现代内存分配器有边界保护，可能是这样的
   [保护字节][元数据][用户数据][保护字节]
   */
   ```

   

2. malloc更底层的原理是什么？一次malloc底层都经历了什么？

   等待以后有空深入研究

   <a id="destination"></a>

3.  堆内存和栈内存的区别？

   | 特性       | 堆内存                     | 栈内存                         |
   | ---------- | -------------------------- | ------------------------------ |
   | 管理方式   | 编译器自动管理（LIFO）     | 程序员手动管理（new/delete）   |
   | 分配速度   | 极快（移动指针             | 较慢（可能需要系统调用）       |
   | 内存碎片   | 无                         | 可能产生                       |
   | 缓存局部性 | 优（连续分配）             | 差（分散分配）                 |
   | 线程安全   | 天然安全（线程独立）       | 需要同步机制（如锁）           |
   | 容量       | 固定且较小（易溢出）       | 动态扩展（受系统内存限制）     |
   | 适用场景   | 局部变量、小对象、短期数据 | 大对象、动态数据结构、长期数据 |

4. 栈数组下标越界访问会发生什么？

   ```C++
   //1.崩溃。情况1:访问受保护的内存；情况2:破坏栈帧结构
   //情况1:
   int nums[5]={0};
   // 访问栈下方的保护页（通常有guard page）
   int value = nums[-1000]; // 可能立即段错误
       
   // 访问栈上方的保护区域
   int value2 = nums[1000]; // 可能立即段错误
   //情况2:
   void functionA() {
       int array[3] = {1, 2, 3};
       array[5] = 0xdeadbeef; // 覆盖返回地址
       // 函数返回时跳转到非法地址，导致崩溃
   }
   
   void functionB() {
       int a = 10, b = 20;
       int array[2] = {1, 2};
       array[3] = 100; // 可能覆盖局部变量b
       std::cout << b; // 输出可能变成100
   }
   //2.数据破坏。情况1:覆盖相邻局部变量；情况2:破坏函数调用栈
   //情况1:
   void silentDataCorruption() {
       int important_value = 42;
       int passwords[3] = {111, 222, 333};
       int another_value = 100;
       
       // 越界写入，破坏相邻变量
       passwords[4] = 999; // 可能修改important_value或another_value
       
       std::cout << "重要值: " << important_value << std::endl; // 可能不是42了
       std::cout << "另一个值: " << another_value << std::endl; // 可能不是100了
   }
   //情况2:
   void victimFunction(int x) {
       std::cout << "参数x: " << x << std::endl;
   }
   
   void attackerFunction() {
       int buffer[2] = {1, 2};
       int local_var = 50;
       
       // 越界访问可能修改调用者的栈帧
       buffer[3] = 666; // 可能修改victimFunction的参数x
       
       victimFunction(100); // 可能输出"参数x: 666"
   }
   //3.安全漏洞。情况1:栈溢出攻击基础（栈缓冲区溢出攻击）情况2:信息泄露
   //情况1:
   void vulnerableFunction(const char* input) {
       char buffer[64]; // 固定大小的栈缓冲区
       
       // 危险的字符串操作
       strcpy(buffer, input); // 如果input超过63字符，就会越界
       
       // 攻击者可以精心构造input来覆盖返回地址
   }
   
   void demoExploit() {
       char exploit[100];
       memset(exploit, 'A', 100);
       // 在特定位置插入恶意代码地址
       *(void**)(exploit + 72) = (void*)malicious_code;
       
       vulnerableFunction(exploit); // 触发漏洞
   }
   ```

5. 什么是栈溢出？

   栈溢出是指，向栈内存写入数据时，写入了超过分配的内存大小的情况，使用了超过的、不受监管的、相邻的内存空间

6. 了解常见的栈溢出手段

   攻击核心原理：

   栈的内存布局是攻击的基础。当一个函数被调用时，栈上会压入（大致顺序如下）：

   1. **函数参数**
   2. **返回地址 (Return Address)**：这是攻击的主要目标。它告诉函数执行完毕后应该回到哪里继续执行。
   3. **旧的栈帧指针 (Old EBP/RBP)**
   4. **局部变量**

```C++
#include <iostream>
#include <cstring>

void vulnerable_function(const char* input) {
    char buffer[64]; // 在栈上分配一个64字节的缓冲区
    strcpy(buffer, input); // 🚨 危险！如果input超过64字节，将发生溢出
    std::cout << "Received: " << buffer << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc > 1) {
        vulnerable_function(argv[1](@ref); // 攻击者通过命令行参数传入超长字符串
    }
    return 0;
}
```

## 内存布局（堆 vs 栈）

1. 基本概念理解：

理解栈内存（Stack Memory）是自动分配和释放的，通常用于存储局部变量、函数参数等。

理解堆内存（Heap Memory）是动态分配和释放的，通过malloc、calloc、realloc等函数分配，通过free释放。

理解栈内存和堆内存在内存管理、作用域、生命周期等方面的区别。

参考：[堆内存和栈内存的区别](#destination)

2. 堆内存的使用：

能够使用malloc、calloc、realloc等函数在堆上动态分配内存。

能够检查这些函数的返回值以确保内存分配成功。

能够在不再需要时，使用free函数释放堆内存，避免内存泄漏。

3. 栈内存与堆内存的对比：

能够通过编程实践展示栈内存和堆内存的不同使用场景和特性。

参考：[堆内存和栈内存的区别](#destination)

## 函数指针 指针函数

函数指针

1.基本概念理解：理解函数指针是存储函数地址的变量，能够通过该指针调用对应的函数。

2.声明与使用：掌握如何正确声明函数指针变量，包括其指向的函数类型（返回类型、参数列表）。

```C++
函数返回值类型 (*funcptr)(函数的参数列表);
```



3.赋值与调用：掌握如何给函数指针赋值（即赋予函数地址），以及如何通过函数指针调用函数。

```C++
int add(int a,int b){
  return a+b;
}
int* (*padd)(int,int)=add;
//后续可以通过padd调用add
int num=padd(1,2);
```



指针函数

1. 基本概念理解：理解指针函数是返回指针的函数，而非函数指针。

2. 声明与使用：掌握如何正确声明指针函数，包括其返回类型（指针类型）和参数列表。

```C++
int* func(参数列表){
  int* p=nullptr;
  return p;
}
```



3. 返回值：理解指针函数返回的是指针类型的数据，并能正确使用这些返回值。

1. 理解函数指针的使用场景。

   1）回调函数，上层传入一个上层的函数给底层，然后把函数的执行交给底层来调用，回调函数故名思义就是回头调用的函数，常用来实现事件处理、异步操作等。

   2）策略模式（可插拔算法），根据需求不同替换执行的函数，比如各种排序算法，根据函数指针决定调用什么排序算法。

   3）函数表（跳转表 / 虚拟函数替代）

   ```C++
   #include <iostream>
   using namespace std;
   
   void add() { cout << "Add\n"; }
   void sub() { cout << "Sub\n"; }
   void mul() { cout << "Mul\n"; }
   
   int main() {
       void (*ops[3])() = {add, sub, mul}; // 函数指针数组
       int choice;
       cin >> choice;
       if (choice >= 0 && choice < 3)
           ops[choice]();  // 动态调用对应函数
   }
   ```

   4）面向对象编程之前的多态实现。

   总之，函数指针的目的就是 **让函数调用从“编译时确定”变成“运行时决定”**。

2. 理解模板方法设计模式，尝试将函数指针运用在模板方法设计模式中。

   ```C++
   //参考gpt给出的代码
   #include <iostream>
   #include <vector>
   using namespace std;
   
   // 模板方法类
   class DataProcessor {
   public:
       using ProcessFunc = void(*)(vector<int>&); // 定义函数指针类型
   
       DataProcessor(ProcessFunc func) : processFunc(func) {}
   
       // 模板方法（固定算法骨架）
       void run() {
           readData();
           processFunc(data); // 可变步骤，用函数指针替代
           outputData();
       }
   
   private:
       vector<int> data;
   
       void readData() {
           data = {5, 2, 9, 1, 7};
           cout << "读取数据完成\n";
       }
   
       void outputData() {
           cout << "结果: ";
           for (int x : data) cout << x << " ";
           cout << endl;
       }
   
       ProcessFunc processFunc; // 保存“可变步骤”的函数指针
   };
   
   // 具体实现1：排序
   void sortData(vector<int>& data) {
       sort(data.begin(), data.end());
       cout << "已排序\n";
   }
   
   // 具体实现2：翻倍
   void doubleData(vector<int>& data) {
       for (auto& x : data) x *= 2;
       cout << "已翻倍\n";
   }
   
   int main() {
       DataProcessor p1(sortData);   // 算法骨架 + 排序实现
       DataProcessor p2(doubleData); // 算法骨架 + 翻倍实现
   
       p1.run();
       p2.run();
   }
   
   ```

   ## 回调函数的理解

   1.基本概念理解：

   1.1理解回调函数是一种通过函数指针调用的函数，它作为参数传递给另一个函数。

   1.2理解回调函数允许上层代码将一段代码传递给底层模块，由底层模块在适当的时候调用。

   1.3了解回调函数通常用于事件处理、异步编程等场景。

   2.函数指针的使用：

   2.1掌握如何声明函数指针变量。

   2.2掌握如何将函数地址赋给函数指针变量。

   2.3理解如何通过函数指针调用函数。

   3.回调函数的实现：

   3.1能够设计包含回调函数作为参数的函数接口。

   3.2能够编写调用包含回调函数参数的函数，并传递合适的回调函数。

   ```C++
   #include <iostream>
   
   typedef void (*fun_ptr)(int [], int);
   
   void Func(int nums[], int size, fun_ptr callback) {
     //在这个内部可以进行一些别的操作之后，自行决定什么时候调用外部传进来的函数
     callback(nums, size);
   }
   
   void DoubleNums(int nums[], int size) {
       for (int i = 0; i < size; ++i) {
           nums[i] = nums[i] * 2;
       }
   }
   
   
   int main() {
       int nums[] = {1, 2, 3, 4, 5};
       Func(nums, 5, DoubleNums);//把回调函数作为参数传入进去
       for (int i = 0; i < 5; ++i) {
           std::cout << nums[i] << " ";
       }
       return 0;
   }
   ```

   

   4.回调函数的调用时机：

   4.1理解回调函数何时被调用，通常由被调用函数（即包含回调函数作为参数的函数）决定。

   1.理解模板方法设计模式，尝试将回调函数运用在模板方法设计模式中。

   2.使用typedef重命名回调函数的声明，使其可读性更高。

## inline的作用

1.基本概念理解：

1.1理解inline是C++中的一个请求（而非命令），用于向编译器建议将函数体在每个调用点内联展开，以减少函数调用的开销。

1.2理解inline函数通常用于小函数，特别是那些执行速度快且调用频繁的函数。

1.3了解inline函数的定义通常放在头文件中，以避免链接时重复定义的问题。

2.使用场景与限制：

2.1理解inline函数不能包含复杂的控制结构（如循环和递归）。

2.2了解编译器可能忽略inline请求，特别是当函数体较大或包含复杂逻辑时。

理解概念、作用和使用即可。

## enum class的作用

基本概念理解：

1.理解enum class是C++11中引入的一种枚举类型，它提供了类型安全和作用域隔离。

<a id="2"></a>

2.理解enum class与普通枚举的主要区别（如作用域、类型安全、隐式转换的限制等）。

```C++
enum class Color{
  kRed=0,
  kGreen,
  kBlue
}
enum Color1{
  kred=0,
  kgreen,
  kblue
}
//作用域
//enum class 在访问时必须加上空间，而enum则是全局范围，比如，Color::xxx,才能使用，而enum则可以直接使用比如kred。
//类型安全、隐式转换
//就比如，Color1 red=kred；int x=0；if（red==x）此时就会有类型安全问题，发生隐式转换，red会被转换成int类型，而enum class就没有这种问题
```



作用域与类型安全：

1.理解enum class的枚举成员默认具有强作用域，需要通过枚举类型名来访问。

2.理解enum class的类型安全性，即不能直接进行不同类型枚举之间的隐式转换。

枚举值的定义与访问：

1.掌握如何在enum class中定义枚举值。

2.掌握如何通过枚举类型名加枚举值名的方式来访问枚举值。

枚举值的类型转换：

1.理解从enum class枚举值到基础数据类型（如int）的显式转换方法。

```C++
//使用类型转换可以做到
int rgb_r=std::static_cast<int>(kRed);
```



2.理解为什么需要显式转换，以及这种设计如何增强类型安全。



1.如何将int值转成enum class类型？

同强类型枚举类转换成int一样，使用static_cast显式转换

2.enum和enum class的区别是什么？

参考：[理解enum class与普通枚举的主要区别](#2)

## const的理解

基本概念理解：

1.理解const用于声明常量，即其值在初始化后不能被修改。

2.理解const可以修饰变量、指针、函数的参数、返回值以及成员函数。

const变量的使用：

1.掌握如何声明const变量并理解其不可变性。

2.理解const变量的作用域和生命周期。

const指针的使用：

1.区分const指针（指向常量的指针）和指针常量（常量指针）。

```C++
int const*p;//这两种写法是一样的，真正的区别点在于是const修饰*还是*修饰const
const int* p;//指向int常量的指针,防止通过这个指针修改对象，但是指针可以指向其他对象
int* const p;//指向int的常量指针，指向int非const的值，但是指针不能修改指向的地址

```



2.理解const指针如何防止指针指向的内容被修改。

3.掌握const指针的声明和初始化。

const修饰函数参数和返回值：

1.理解const修饰函数参数的作用（保证参数在函数内不被修改）。

2.理解const修饰函数返回值的作用（防止返回值的误修改，特别是返回指针或引用时）。

const成员函数：

1.理解const成员函数保证在调用过程中不会修改对象的任何成员变量（除了mutable修饰的变量）。

2.掌握如何在类成员函数中声明和使用const限定符。

1. 在const成员函数中，能否加锁和解锁，为什么？

   可以的，但是也要加上mutable修饰，否则就不行。

2. const和define的区别？

   define是宏定义，全局有效，在编译期之前（预处理阶段，直接替换文本），没有类型检查

   const有作用域范围，在编译期处理，有类型检查

3. char*、const char*、char* const、const char* const 有什么区别？

   char定义一个字符变量，const char定义一个不可修改的字符变量，char* cosnt定义一个不可修改指向的字符指针，const char* const定义一个不可修改指向的，指向一个字符常量。

4. volatile关键字的作用是什么？

   `volatile` 是 C/C++ 中的一个关键字，用来告诉编译器：**这个变量的值可能随时被外部环境改变，所以不要对它进行优化**。

   换句话说，`volatile` **防止编译器对变量进行“假设不变”的优化**。

   当一个变量被 `volatile` 修饰时：

   1. **每次访问都必须从内存中读取**，不能使用寄存器缓存的值。
   2. **不能对访问顺序进行优化**，保证读写操作的时序严格按照代码顺序。

## constexpr的理解

和const大差不差

基本概念理解：

1.理解constexpr用于声明编译时常量，即其值在编译时就能确定。

2.理解constexpr可以修饰变量、函数。

constexpr变量的使用：

1.掌握如何声明constexpr变量并初始化。

2.理解constexpr变量的作用域和生命周期。

3.了解constexpr变量可以用于数组大小、模板参数等需要编译时常量的场景。

constexpr函数的使用：

1.掌握如何编写constexpr函数，确保函数体内的操作都是编译时可知的。

2.理解constexpr函数可以在需要编译时常量的地方被调用，如模板参数、数组大小等。

3.了解constexpr函数在运行时也可以被调用，此时它们表现得和普通函数一样。

## 引用的理解

基本概念理解：

1. 理解引用是变量的别名，不是变量本身，也不是变量的拷贝。

2. 理解引用在定义时必须被初始化，且一旦被绑定到一个变量上，就不能再被绑定到另一个变量上。

引用的使用：

1. 掌握如何通过引用来访问和修改它所引用的变量的值。

2. 理解引用在函数参数传递中的作用，特别是与指针相比的优势（如语法简洁性和类型安全性）。

   1）避免拷贝；2）可以直接修改参数的数据。

   优势：语法简洁，使用起来就像直接操作对象一样，指针就必须要使用解引用`*`符号访问数据。

   类型安全，首先是引用必须初始化，不会有指针为空的特殊情况，不需要判断指针是否为`NULL`and `nullptr`的情况，

   不可重复绑定，引用一旦初始化绑定一个对象后，就不能再修改了，可以避免指针出现“野指针”或是“悬垂指针”的问题（虽然可能会出现悬垂引用的情况，但因为引用不可重新赋值，所以来源可控清晰）

1. 函数参数中是否可以使用const 引用形式，有什么优点吗？

   可以，1）避免不必要的拷贝，提高性能；2）保证函数不修改原始对象；3）const修饰后支持右值传入。

2. 函数参数中使用non-const 引用形式的目的是什么？

   在函数参数中使用 `non-const` 引用形式（即 `T&`）有明确且特定的目的，但它是一把"双刃剑"，需要谨慎使用。

   **核心目的：允许函数修改调用者的对象**

   **`non-const` 引用的最主要目的就是让函数能够直接修改传递给它的实际参数（实参）**。函数内部对引用参数的任何修改都会直接反映到调用处的原始变量上。

## 引用 vs 指针

指针与引用的区别

1.存储方式：

1.1指针：是变量，存储的是内存地址。

1.2引用：是变量的别名，不存储地址，通过别名直接访问原始变量。

2.初始化：

2.1指针：可以不初始化（但应避免，以免成为野指针），初始化时需要显式地给出地址。

2.2引用：必须在定义时初始化，且一旦初始化后不可再改变为引用另一个变量。

3.空值：

3.1指针：可以指向空（nullptr或NULL），表示不指向任何对象。

3.2引用：必须总是指向某个对象，不存在空引用的概念。

4.多级引用/指针：

4.1指针：可以有多级指针（如int**），指向另一个指针。

4.2引用：不支持多级引用，即不能定义引用的引用。

5.函数参数与返回值：

5.1指针：作为参数传递时，可以修改原始数据（如果指向了非const对象）。作为返回值时，需要注意生命周期问题。

5.2引用：作为参数传递时，同样可以修改原始数据（如果非const）。作为返回值时，更安全，因为不需要担心指针的生命周期问题。

使用场景

1.当需要指向空值或重新指向另一个对象时，使用指针。

2.当需要在函数间安全地传递大型对象或需要修改函数参数时，优先考虑引用（除非有指向空或重新指向的需求）。

3.在需要动态内存分配或管理内存时，使用指针。

4.在需要避免拷贝大型对象以提高效率时，使用引用（特别是作为函数参数或返回值）。
