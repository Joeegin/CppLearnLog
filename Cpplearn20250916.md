# 2025年9月16日

## iterator的理解

### 基本概念理解：

1. 理解迭代器是什么，以及它们在C++ STL中的作用。

2. 了解迭代器的基本操作，如递增（++）、递减（--）、解引用（*）、成员访问（->）和比较（==, !=）。

3. 理解迭代器失效的概念，特别是在修改容器内容时的迭代器失效情况。

   ```C++
   //类似如下这种情况，边迭代边修改原容器大小之类的操作
   #include <iostream>
   
   int main() {
       std::vector<int> nums{1, 2, 3, 4, 5};
       for (const auto &num: nums) {
           std::cout << num << " ";
       }
       std::cout << std::endl;
       for (auto &i: nums) {
           nums.push_back(i);
           std::cout << i << " ";
       }
       return 0;
   }
   /*
   1 2 3 4 5 
   -1080505792 1484 2043 0 0 
   进程已结束，退出代码为 0
   */
   ```

   


### 迭代器的分类：

1. 了解不同类型的迭代器（如输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器）及其特性。

2. 理解不同类型迭代器支持的操作和性能差异。

### 迭代器与容器的关系：

1. 理解容器如何提供迭代器来访问其元素。

2. 了解如何获取容器的开始迭代器（begin()）和结束迭代器（end()）。
### 迭代器的高级用法：

1. 掌握如何使用迭代器进行范围for循环（C++11及以后）。

2. 了解如何使用迭代器算法（如std::find, std::copy, std::sort等）。

1. std::sort可以对所有类型的迭代器都排序吗？
2. C++为什么要引入迭代器？直接操作具体容器不好吗？
3. 迭代器和指针有什么区别？

## vector的使用与理解

### 基本概念理解：

1. 理解std::vector是一个模板类，用于存储元素序列，并自动管理内存。

2. 了解std::vector支持随机访问，即可以通过索引直接访问任意位置的元素。

3. 掌握std::vector的基本操作，如添加（push_back）、删除（erase）、访问（operator[]）、遍历（迭代器或范围for循环）等。

### std::vector的扩容机制：

1. 理解std::vector在添加元素时可能会进行扩容，以及扩容的时机和策略。

2. 了解扩容操作可能导致迭代器、指针和引用的失效。

### 迭代器与std::vector：

1. 掌握如何使用迭代器遍历std::vector中的元素。

2. 了解std::vector的迭代器是随机访问迭代器，支持所有迭代器操作。

### std::vector的容量与大小：

1. 理解std::vector的size()和capacity()成员函数的区别和用途。

   size是元素个数，capacity是当前容量。

2. 掌握如何手动调整std::vector的容量（通过reserve和shrink_to_fit）。

   reserve预分配容量，shrink_to_fit是收缩容量和size大小相等。

1. vector的emplace_back和push_back的区别是什么？

   push_back是拷贝或者移动资源到末尾，emplace_back是直接在末尾内存内构造。性能会好一些。

2. vector的扩容，一定是按倍数扩容吗？有没有什么场景它不按倍数扩容？写代码测试下。

   扩容倍数看具体编译器，gcc和clang是两倍扩容，msvc不完全是两倍扩容，约为1.5倍。

   可以自己实现allocator内存管理器实现自定义扩容机制。

3. vector中如果存储的是bool，也就是vector<bool>，有哪些优缺点？

   1）内存效率高；2）位操作优化，可以像bitset一样操作。

   1）不是真正的容器（不能取地址）；2）算法兼容性；3）性能问题

   使用建议：

   - 需要动态大小和容器语义：`std::vector<char>`
   - 需要固定大小和最高效：`std::bitset`
   - 需要动态大小和平衡：`std::deque<bool>`

   **建议**：只有在确实需要极致内存优化，且能接受其限制时，才使用 `std::vector<bool>`。

4. vector内部使用的内存，是堆内存还是栈内存？

   堆内存

5. vector和list有什么区别？

   **`vector`**：动态数组。在内存中是**一段连续的内存空间**。

   **`list`**：双向链表。在内存中是**通过指针连接的一系列离散节点**。

   | 特性              | std::vector (动态数组)                                 | std::list (双向链表)                                         |
   | :---------------- | :----------------------------------------------------- | :----------------------------------------------------------- |
   | **底层数据结构**  | 动态数组，一段连续内存                                 | 双向链表，非连续内存节点                                     |
   | **内存连续性**    | **连续**                                               | **非连续**                                                   |
   | **随机访问**      | **支持，速度快 (O(1))** （如 `vec[500]`）              | **不支持，速度慢 (O(n))** （必须从头或尾遍历）               |
   | **中间插入/删除** | **慢 (O(n))** （需要移动后续所有元素）                 | **快 (O(1))** （只需修改指针）                               |
   | **末尾插入/删除** | **快，摊销常数 (O(1))**                                | **快 (O(1))**                                                |
   | **开头插入/删除** | **慢 (O(n))** （需要移动所有元素）                     | **快 (O(1))**                                                |
   | **内存占用**      | 较小，仅需数组本身+少量开销                            | 较大，每个节点都包含两个指针的开销                           |
   | **缓存友好性**    | **高** （数据连续，空间局部性好）                      | **低** （数据分散，容易缓存缺失）                            |
   | **迭代器类型**    | 随机访问迭代器                                         | 双向迭代器                                                   |
   | **迭代器失效**    | 插入/删除可能导致**所有迭代器**失效 （如引起重新分配） | **只有指向被删除元素的迭代器**会失效 插入操作不会使任何迭代器失效 |

6. vector的实现原理是什么，尝试自己实现一个简单的vector？

   