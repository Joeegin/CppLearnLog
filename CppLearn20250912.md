# 2025年9月12日

## 左值、右值、左值引用、右值引用

基本概念理解

1.理解左值（Lvalue）是持久化对象，有确定的内存地址，可用于赋值操作（等号）的左侧。

2.理解右值（Rvalue）是临时对象，没有确定的内存地址（或者说，其地址对程序员不可见），通常用于赋值操作（等号）的右侧。

3.理解左值引用是对左值的引用，使用&符号声明。

4.理解右值引用是对右值的引用，使用&&符号在C++11及以后版本中声明。

左值引用与右值引用的使用

1.掌握左值引用不能绑定到右值上的规则（除非使用std::move进行强制转换）。

2.掌握右值引用可以绑定到右值上的特性，以及如何利用这一特性实现移动语义。

```c++
template<typename T>
void printType(T &&arg) {
    // if constexpr用于编译时条件判断，不满足分支不会生成代码，如果没有constexpr修饰，会编译出错
    // 因为std::is_lvalue_refernce<T>::value是一个编译时常量，而if只在运行时判断
    if constexpr (std::is_lvalue_reference<T>::value) {
        std::cout << " 是左值\n";
    } else {
        std::cout << " 是右值\n";
    }
}
```



完美转发与std::forward

1.理解完美转发（Perfect Forwarding）的概念，即能够将函数模板的参数按照其原始类型（左值或右值）转发给另一个函数。

2.掌握std::forward的用法，它是实现完美转发的重要工具。

```C++
template<typename T>
void printType(T &arg) {
    std::cout << "左值引用\n";
}

template<typename T>
void printType(T &&arg) {
    std::cout << "右值引用\n";
}

template<typename... Args>
void forwarder(Args &&... args) {
    (printType(std::forward<Args>(args)), ...);
}

int main() {
    int x = 0;
    int &y = x;
    forwarder(x, 0, 1 + 1, std::move(x), y);

    return 0;
}
```

1. 为什么要引入完美转发？使用完美转发可以解决什么问题？

   因为通过中间函数的参数传递后，因为这个参数是具名的，所以无论原参数是左值还是右值，这里都会变成左值。

   完美转发的出现就是为了解决这种问题，完美转发可以让参数传递时保持原有的左右值信息。

## auto decltype

auto 关键字的理解与使用

1.理解auto关键字用于自动类型推导，编译器会根据初始化表达式自动推断变量的类型。

2.掌握auto关键字的使用场景，如复杂的类型声明、迭代器类型、Lambda表达式等。

3.了解auto不能用于函数参数的声明，以及它如何与const、&（引用）和*（指针）结合使用。

```C++
//1、auto在定义时必须马上初始化
auto e;//error
//2、一行多个变量时必须是同一类型
//3、会忽略cv属性和const
/*
1.auto使用必须马上初始化
2.auto一行定义多个变量时不能有二义性，否则编译会报错
3.auto不能用作函数参数
4.在类中auto不能用作非静态成员变量
5.auto不能定义数组，但是可以定义指针
6.auto无法推导出模板参数
*/
```



decltype 关键字的理解与使用

1.理解decltype关键字用于查询表达式的类型，包括表达式的值类别（左值或右值）。

2.掌握decltype的使用场景，如模板编程中需要根据函数参数类型推导返回类型等。

3.了解decltype在处理复杂表达式和类型时的注意事项，如表达式的副作用、引用折叠等。

```c++
//推导规则
/*
1.表达式类型，decltype（exp）的类型和exp类型相同，除非exp是左值
2.函数调用，decltype（exp）与exp函数的返回值类型相同
3.左值引用，如果exp是左值，则decltype（exp）是exp类型的左值引用
4.保留cv属性和引用
*/
int x=0;
decltype(x) y;//y是int类型，不是int&
//为什么这里不一样？当是变量名时，decltype会直接获取该变量的声明类型如果是decltype（（x））时，结果就不一样了，此时就会推导表达式结果的类型和值类别，然后添加引用
```

发散题：你什么场景下会用到auto，什么场景下使用实际类型，比如int。

主要是复杂类型使用auot，比如迭代器类型，lambda表达式等不清楚类型或是类型复杂的场景。

## move的理解

基本概念理解

1.理解std::move的作用是将参数转换为右值引用，以便利用移动构造函数或移动赋值运算符。

2.理解移动语义的目的是避免不必要的拷贝，特别是在处理大型对象或资源密集型对象时。

3.了解移动后对象的状态应为有效但不确定（通常是安全但不可预测的），即移动后的对象处于“可析构”但“不可用”的状态。

移动构造函数与移动赋值运算符

1.掌握如何为自定义类型实现移动构造函数和移动赋值运算符。

2.了解何时需要禁用拷贝构造函数、拷贝赋值运算符、移动构造函数或移动赋值运算符（例如，如果对象包含不可移动的资源）。

std::move的使用场景

1.理解std::move的正确使用场景，包括在返回局部对象、传递给函数以利用移动语义等场合。

2.认识到std::move仅仅是一个类型转换，实际的移动操作由移动构造函数或移动赋值运算符完成。

  `std::move`只是将一个左值转换成右值，没有别的什么操作，具体要看移动构造函数和移动赋值函数的实现

1. 理解如何通过move触发移动语义

   将左值转换成右值，然后调用移动相关操作。

2. 理解move的作用，以及实现原理

   将左值转换成右值，实现原理就是不管参数是左值还是右值都通过static_cast转换，返回右值。