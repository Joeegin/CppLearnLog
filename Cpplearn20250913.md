# 2025年9月13日

## 对象管理 RAII

### 基本概念理解

1. 理解RAII是什么，以及它在资源管理中的作用。

   资源获取即初始化，将资源的生命周期绑定到对象的生命周期上，实现资源的自动释放。

2. 理解RAII通过对象的构造函数来获取资源，通过析构函数来释放资源的机制。

3. 了解RAII如何帮助避免资源泄露和其他与资源管理相关的错误。

### 实现RAII

1. 能够设计并实现一个符合RAII原则的类，用于管理特定的资源（如动态内存、文件等）。

2. 在类的构造函数中正确获取资源，并在析构函数中正确释放资源。

3. 确保资源在使用完毕后总是能被正确释放，即使发生异常也是如此。

### RAII的实际应用

1. 能够将RAII原则应用于实际的项目中，管理各种类型的资源。

2. 了解并能够避免RAII使用中可能遇到的问题，如资源过早释放或延迟释放。

```c++
/*
题目：实现一个简单的RAII封装类ScopedPtr
要求：
实现一个ScopedPtr类，用于管理动态分配的内存。该类应该具备以下特性：
1.构造函数接受一个指向动态分配内存的指针，并管理该内存。
2.析构函数负责释放该内存。
3.禁用拷贝构造函数和拷贝赋值运算符，以避免复制导致的双重释放问题。
4.提供一个成员函数来访问指向的内存（通过返回裸指针或引用，但需要注意安全性和用途）。
5.提供一个移动构造函数和移动赋值运算符（如果需要的话，视具体实现而定）。
验收标准：
1.ScopedPtr类应能正确管理动态分配的内存，确保在对象生命周期结束时自动释放内存。
2.尝试拷贝ScopedPtr对象时应编译失败（或运行时失败，如果未禁用拷贝构造函数但以其他方式防止拷贝）。
3.ScopedPtr应提供一个安全的方式来访问其管理的内存（如通过成员函数返回一个裸指针或引用），但不应允许通过该访问方式改变ScopedPtr内部的状态或导致资源被提前释放。
4.如果实现了移动构造函数和移动赋值运算符，则它们应能正确地将资源从一个ScopedPtr对象转移到另一个对象，并确保原对象在转移后处于安全状态（通常是设置为空指针）。
编程提示：
可以使用std::unique_ptr作为参考或实现的基础，但请尝试自己从头开始实现一个简化版的ScopedPtr，以加深理解。注意，这里要求禁用拷贝操作，你需要将拷贝构造函数和拷贝赋值运算符声明为delete。
*/
#include <iostream>

template<typename T>
class ScopedPtr {
public:
    ScopedPtr(): ptr_(nullptr) {
    }

    explicit ScopedPtr(T *ptr) : ptr_(ptr) {
    }

    ScopedPtr(const ScopedPtr &other) = delete;

    ScopedPtr &operator=(const ScopedPtr &other) = delete;

    explicit ScopedPtr(ScopedPtr &&other) : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    ScopedPtr &operator=(ScopedPtr &&other) {
        if (this != &other) {
            delete ptr_;
            ptr_ = other.ptr_;
            other.ptr_ = nullptr;
        }
        return *this;
    }

    ~ScopedPtr() {
        delete ptr_;
        ptr_ = nullptr;
        std::cout << "~ScopedPtr()" << std::endl;
    }

    T *get() const {
        return ptr_;
    }

private:
    T *ptr_;
};

int main() {
    ScopedPtr<int> scoped_ptr(new int(10));
    ScopedPtr<int> scoped_ptr1;
    //scoped_ptr1=scoped_ptr;
    //scoped_ptr1(scoped_ptr);
    std::cout << *(scoped_ptr.get()) << std::endl;
    scoped_ptr1 = std::move(scoped_ptr);
    std::cout << *(scoped_ptr1.get()) << std::endl;
    if (!scoped_ptr.get()) {
        std::cout << "scoped_ptr.get() is nullptr" << std::endl;
    }
    return 0;
}
```

1. 理解std::unique_ptr的实现原理

   参考上面代码，主要是禁用拷贝构造和拷贝赋值函数

2. 思考更多RAII的实际巧妙应用，如何动态释放内存，如何动态释放文件资源等，如何通过RAII统计某个作用域的执行时间。

   

## 列表初始化

### 列表初始化的基本概念

1. 理解列表初始化是C++11引入的一种初始化方式，用于初始化变量、数组、容器的元素等。

   使用`{}`来初始化。

2. 理解列表初始化与赋值初始化的区别，特别是在处理构造函数重载时的行为差异。

### 列表初始化的使用场景

1. 掌握在定义对象时，如何使用列表初始化来初始化成员变量。

2. 理解在函数参数传递时，列表初始化如何影响参数的类型推导和重载选择。

3. 熟悉在返回语句中，如何使用列表初始化来初始化返回值。

### 列表初始化的限制和注意事项

1. 理解列表初始化在某些情况下可能导致的类型窄化问题，并知道如何避免。

   ```c++
   class Box {
   public:
       Box(const int &w, const int &h) {
           std::cout << "双int构造" << std::endl;
       }
   
       Box(std::initializer_list<int> list) {
           std::cout << "列表初始化" << std::endl;
       }
   };
   
   int main() {
       Box Box1(1, 2);//双int构造
       Box Box2{1, 2};//列表初始化,使用{}时会优先使用列表初始化
       Box Box3{1, 2, 3};//列表初始化
       return 0;
   }
   ```

1. 写代码测试列表初始化可能导致的类型窄化问题。

   ```C++
   double pi=3.14159;
   int x(pi);//类型窄化，使用{}时，编译器会提示报错
   ```

2. 成员变量的初始化顺序是固定的吗？

   是的，是固定的，和成员变量在类中的声明顺序有关。

## 强制类型转换

### 基本概念理解

1. 理解强制类型转换是在编译时或运行时强制改变表达式的类型。

2. 区分C风格的强制类型转换（(type)expression）与C++风格的四种强制类型转换（static_cast<type>(expression), dynamic_cast<type>(expression), const_cast<type>(expression), reinterpret_cast<type>(expression)）。

### C++风格的强制类型转换

1. 理解static_cast用于基本数据类型之间的转换、对象指针之间的转换（但要求有明确的继承关系且是安全的）、有转换函数的类对象的转换。

2. 理解dynamic_cast主要用于安全地向下转换（即基类指针或引用转换为派生类指针或引用），且仅在多态类型之间有效。

3. 理解const_cast用于修改类型的const或volatile属性。

4. 理解reinterpret_cast用于执行低级别的重新解释类型转换，例如将指针类型转换为足够大的整数类型，或执行不同类型的指针之间的转换。

   低层次位级别重解释，不修改任何底层二进制数据，只是换一种类型解释。

### 强制类型转换的注意事项

1. 认识到强制类型转换可能会导致数据丢失、精度下降或程序崩溃，特别是当类型之间不存在兼容关系时。

2. 知晓dynamic_cast在转换失败时会返回空指针（对于指针）或抛出异常（对于引用）。

### 四种类型转换的使用场景

static_cast:适用于绝大部分情况，包括基本类型的转换；有类型的指针到void*的转换；也可以用在子类指针向父类指针转换，但是父类指针转换成子类指针最好是用dynamic_cast。

dynamic_cast:一般用于将父类指针转换成子类指针，父类必须有虚函数，dynamic是运行时检查，而运行时检查依赖`RTTI`，而`RTTI`又存储在虚函数表中。（如果父类没有虚函数，或转换双方不是父子关系，会返回`nullptr`）

const_cast:一般用于常量指针和非常量指针之间的转换，用来去除cv属性，操作比较危险，谨慎使用。

reinterpret_cast:类似C语言的强制类型转换，基本上什么都能转（低层次位级别重解释，不修改任何底层二进制数据，只是换一种类型解释。）

## 静态static

### 基本概念理解

1. 理解static关键字在C++中的三种主要用途：局部变量静态存储期、全局/命名空间作用域内的隐藏、以及类成员变量的静态成员特性。

2. 理解静态变量（包括静态局部变量和全局静态变量）的生命周期和初始化时机。

3. 理解静态成员函数和非静态成员函数的区别，包括它们对类实例的依赖和访问权限。

### 静态存储期

1. 知道静态局部变量在程序执行期间只初始化一次，并且其值在函数调用之间保持不变。

2. 理解全局静态变量和命名空间内的静态变量的作用域和生命周期。

### 静态成员变量与函数

1. 理解静态成员变量属于类本身，而不是类的某个特定对象。

2. 知道静态成员函数可以没有this指针，因此不能访问类的非静态成员变量和成员函数。

   ```C++
   class A{
   public:
       int getnum(){
           return number_;
       }
       static int getnum2(A& a){
           return a.getnum();
       }
   private:
       int number_;
   };
   ```

   

3. 能够在类定义中声明静态成员变量和函数，并在类外部进行定义和初始化（对于静态成员变量）。

1. 思考题，static类成员函数需要使用到this指针吗？

   **答案：不需要，也不能使用。**

   **详细解释：**

   `this`指针是一个隐含的、指向当前对象实例的指针。它的存在依赖于一个前提：**必须有具体的对象实例被创建**。

   而`static`类成员函数（静态成员函数）具有以下关键特性，这些特性决定了它与`this`指针互斥：

   1. **不依赖于类的实例**：静态成员函数属于类本身，而不是类的任何一个特定对象。你可以在**没有创建任何类的对象的情况下**，直接通过类名和作用域解析运算符`::`来调用它（例如`ClassName::StaticFunction()`）。
   2. **无法访问非静态成员**：因为静态成员函数没有`this`指针，它不知道应该去操作哪个对象的数据。因此，它**只能直接访问类的静态成员变量和其他静态成员函数**。如果尝试在静态成员函数内部直接访问普通的非静态成员变量或调用非静态成员函数，编译器会报错。
   3. **没有对象上下文**：由于调用时可能根本没有对象存在，所以`this`指针也就无从谈起。

2. 什么场景下用到static？

   `static`关键字用途广泛，主要围绕其核心思想：**“与类/文件关联，而非与实例关联”** 和 **“持久化的生命周期”**。

   **场景一：实现“函数内部的状态保持”**

   这是静态局部变量的经典用法。用于记录函数被调用的次数，或者在多次调用间缓存某些数据，而无需使用全局变量。

   **场景二：限制作用域，实现“文件作用域”的变量和函数（信息隐藏）**

   在C++中，这是替代不安全的全局变量的最佳实践。通过在全局变量或函数前加上`static`，可以将其作用域限制在当前源文件内，防止与其他源文件中的同名符号发生命名冲突。

   **场景三：定义类的常量和工具函数（静态类成员）**

   1. **类级别的常量**：如果一个常量被类的所有对象所共享，并且值不变，应该将其定义为`static const`或`static constexpr`。

      ```c++
      class Math {
      public:
          static constexpr double PI = 3.1415926535;
      };
      // 使用：double circleArea = Math::PI * radius * radius;
      ```

   2. **共享数据**：当一个数据需要被类的所有实例共享和修改时（例如，统计当前已创建的对象数量）。

      ```c++
      class Player {
          static int count; // 统计玩家人数
      public:
          Player() { count++; }
          ~Player() { count--; }
          static int getPlayerCount() { return count; }
      };
      ```

   3. **工具函数**：一些不操作对象成员数据、只完成特定任务的函数，适合作为静态成员函数。它们就像命名空间下的普通函数，但逻辑上归属于某个类。

      ```c++
      class StringUtils {
      public:
          static bool isEmpty(const std::string& str);
          static std::string toUpper(const std::string& str);
      };
      // 使用：if (StringUtils::isEmpty(myString)) ...
      ```

      **场景四：单例模式（Singleton Pattern）**

      这是静态成员变量和函数的综合应用。确保一个类只有一个实例，并提供一个全局访问点。

      ```c++
      class Singleton {
      private:
          Singleton() {} // 构造函数私有化
          static Singleton* instance; // 静态指针，指向唯一的实例
      
      public:
          // 静态方法，用于获取唯一实例
          static Singleton* getInstance() {
              if (instance == nullptr) {
                  instance = new Singleton();
              }
              return instance;
          }
      
          // 删除拷贝构造函数和赋值操作符，确保不能复制
          Singleton(const Singleton&) = delete;
          void operator=(const Singleton&) = delete;
      };
      
      // 在类外初始化静态成员变量
      Singleton* Singleton::instance = nullptr;
      ```

      **场景五：优化与缓存（Meyer's Singleton）**

      利用静态局部变量在C++11后的线程安全特性，实现更优雅、线程安全的单例或进行一次性初始化。

      ```c++
      class SomeResource {
      public:
          static SomeResource& getResource() {
              static SomeResource instance; // 线程安全且只在第一次调用时初始化
              return instance;
          }
      };
      ```

      **总结一下，使用`static`的关键场景：**

      - **需要持久化状态**，但又不想用全局变量时（用静态局部变量）。
      - **需要隐藏信息**，避免命名冲突时（用静态全局变量/函数）。
      - **需要表示类级别**的、被所有对象共享的数据或操作时（用静态类成员）。
      - **需要控制实例数量**，实现单例或管理器类时。

