# 2025年9月11日

## new delete new[] delete[]的使用和理解

基本概念理解

1.理解new和delete用于单个对象的动态内存分配和释放。

2.理解new[]和delete[]用于对象数组的动态内存分配和释放。

3.了解使用这些操作符时，构造函数和析构函数的调用时机。

内存分配与释放

1.掌握如何正确使用new和new[]进行内存分配。

```C++
//int可以换成任意数据类型包括类
int* a=new int(5);
int* nums=new int[5];
```



2.掌握如何正确使用delete和delete[]释放已分配的内存，避免内存泄漏。

```C++
//内置类型new和delete可以不配套使用，系统知道具体大小，但是保险起见一定要配套使用，并且记得有new就有delete
delete a;
delete[] nums;
```



3.理解不匹配使用new/delete与new[]/delete[]会导致的未定义行为。

```C++
// new配合delete[]使用时,delete会向前左移动4字节或8字节（用于记录内存大小），但是new创建内存空间时并没有使用头部的空间，会出现意想不到的未定义情况，然后崩溃
// new[]配合delete使用时，delete只释放了new[0]上的内存，但是new[]创建时会在头部写入内存空间大小，导致头部未释放并且new[0]以后的数据全都没有释放，然后程序崩溃
```



异常安全

1.了解在分配内存时如果发生异常（如std::bad_alloc），new会抛出该异常，并需要相应的异常处理机制。

```C++
try{
  int* a=new int(1);
}catch(std::bad_alloc & e){
  //异常处理
}
```

## 拷贝构造 移动构造 赋值构造 移动赋值 移动语义

拷贝构造函数

1.理解拷贝构造函数的作用：在创建对象时，使用另一个同类型对象初始化该对象。

```C++
Object(const Object& other){
  //深拷贝other对象的资源
}
Object a；
Object b(a);
```



2.掌握拷贝构造函数的声明和定义，确保深拷贝或适当的行为以避免资源泄露或重复释放。

3.了解编译器生成的默认拷贝构造函数的行为。

4.理解深拷贝与浅拷贝的区别。

```C++
/*
浅拷贝是看起来像是拷贝了另一个对象的值,实际只是简单的访问另一个对象的资源，
假设有两个对象A和B，对象A的一个资源在一块内存比如0x0001上，浅拷贝情况下是让对象B也指向这个内存地址0x0001，达到获取资源。
深拷贝是指完全复制一份资源，还是上面的例子，深拷贝情况下对象B指向内存地址0x0002，但是内存地址0x0002的内容是0x0001的复制，是一样的内容，这就是深拷贝。
*/
```



移动构造函数

1.理解移动构造函数的作用：在创建对象时，从另一个即将被销毁的临时对象“窃取”资源。

```C++
Object(const Object&& other){
  //浅拷贝，但是要让other放弃资源的访问
}
```



2.掌握移动构造函数的声明和定义，确保资源被正确转移。

3.了解std::move函数和std::forward函数在移动语义中的作用。

```C++
/*
std::move()将一个左值转换成右值引用
std::forward()保留对象的左右值属性，完美转发，根据名字可以看出，当出现中间一层时，会因为参数传递的具名变量变成左值，完美转发就是为了防止这种情况
*/
```



赋值构造函数（赋值运算符重载）

1.理解赋值运算符重载的作用：实现对象之间的赋值操作。

```C++
Object& operator=(const Object& other){
  //先释放本身的资源，然后再深拷贝资源，需要注意自赋值情况！
}
```



2.掌握赋值运算符重载的声明和定义，确保深拷贝或适当的资源管理。

3.了解自赋值（self-assignment）问题及其解决方案。

移动赋值运算符重载

1.理解移动赋值运算符重载的作用：从一个即将被销毁的临时对象“窃取”资源并赋值给当前对象。

2.掌握移动赋值运算符重载的声明和定义，确保资源被正确转移并处理自赋值情况。

移动语义

1.理解移动语义的概念及其在资源管理中的作用。

2.能够根据需要使用移动构造函数和移动赋值运算符来提高性能。