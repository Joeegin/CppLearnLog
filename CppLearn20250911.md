# 2025年9月11日

## new delete new[] delete[]的使用和理解

基本概念理解

1.理解new和delete用于单个对象的动态内存分配和释放。

2.理解new[]和delete[]用于对象数组的动态内存分配和释放。

3.了解使用这些操作符时，构造函数和析构函数的调用时机。

内存分配与释放

1.掌握如何正确使用new和new[]进行内存分配。

```C++
//int可以换成任意数据类型包括类
int* a=new int(5);
int* nums=new int[5];
```



2.掌握如何正确使用delete和delete[]释放已分配的内存，避免内存泄漏。

```C++
//内置类型new和delete可以不配套使用，系统知道具体大小，但是保险起见一定要配套使用，并且记得有new就有delete
delete a;
delete[] nums;
```



3.理解不匹配使用new/delete与new[]/delete[]会导致的未定义行为。

```C++
// new配合delete[]使用时,delete会向前左移动4字节或8字节（用于记录内存大小），但是new创建内存空间时并没有使用头部的空间，会出现意想不到的未定义情况，然后崩溃
// new[]配合delete使用时，delete只释放了new[0]上的内存，但是new[]创建时会在头部写入内存空间大小，导致头部未释放并且new[0]以后的数据全都没有释放，然后程序崩溃
```



异常安全

1.了解在分配内存时如果发生异常（如std::bad_alloc），new会抛出该异常，并需要相应的异常处理机制。

```C++
try{
  int* a=new int(1);
}catch(std::bad_alloc & e){
  //异常处理
}
```

1. new的返回值，需要判断是否是nullptr吗？

   不需要，new创建失败时不会返回一个nullptr，而是会抛出std::bad_alloc异常，想要返回nullptr时，可以用new(std::nothrow)，此时不会抛出异常。

2. new操作背后，都有哪些流程？

   首先是分配内存，然后进行检查，创建成功后直接在内存中调用构造函数，最后返回出这个内存的地址。

3. new和malloc有什么区别？

   | 特性         | `new/delete`                                       | `malloc/free`                                |
   | ------------ | -------------------------------------------------- | -------------------------------------------- |
   | **作用**     | 分配内存 + 调用构造函数 / 调用析构函数 + 释放内存  | 只分配/释放内存，不会调用构造/析构           |
   | **返回类型** | 返回指定类型的指针，不需要强制转换                 | 返回 `void*`，需要强转成目标类型             |
   | **失败处理** | 分配失败抛 `std::bad_alloc`（除非 `nothrow`）      | 分配失败返回 `nullptr`                       |
   | **大小参数** | 编译器根据类型推导大小，不需要手动传               | 需要手动传递字节数                           |
   | **重载**     | 可以为类重载 `operator new/delete`（自定义内存池） | 只能用全局的 `malloc/free`，不可为类单独定制 |
   | **内存位置** | 默认从堆分配（可自定义）                           | 从堆分配                                     |

4. new出来的指针，可用free释放吗？

   不能，new会调用构造函数，如果不用delete释放，会导致析构函数未执行。

   思考🤔：如果是内置类型比如int呢？

   gpt给出的回答：

   - 对 `int` 这种内置类型来说，**没有析构函数**，所以你可能会觉得：
      “那不是和 `delete` 一样吗？反正都只是释放内存。”
   - 但是，标准规定 **必须配对**：
     - `new` ↔ `delete`
     - `new[]` ↔ `delete[]`
     - `malloc` ↔ `free`

   如果你用 `free(p)` 释放 `new` 出来的 `int`，这是 **未定义行为 (UB)**。
   虽然在很多实现上看似“能跑通”，但标准并不保证。未来可能换编译器/库/优化，就会崩。





## 拷贝构造 移动构造 赋值构造 移动赋值 移动语义

拷贝构造函数

1.理解拷贝构造函数的作用：在创建对象时，使用另一个同类型对象初始化该对象。

```C++
Object(const Object& other){
  //深拷贝other对象的资源
}
Object a；
Object b(a);
```



2.掌握拷贝构造函数的声明和定义，确保深拷贝或适当的行为以避免资源泄露或重复释放。

3.了解编译器生成的默认拷贝构造函数的行为。

4.理解深拷贝与浅拷贝的区别。

<a id="1"></a>

```C++
/*
浅拷贝是看起来像是拷贝了另一个对象的值,实际只是简单的访问另一个对象的资源，
假设有两个对象A和B，对象A的一个资源在一块内存比如0x0001上，浅拷贝情况下是让对象B也指向这个内存地址0x0001，达到获取资源。
深拷贝是指完全复制一份资源，还是上面的例子，深拷贝情况下对象B指向内存地址0x0002，但是内存地址0x0002的内容是0x0001的复制，是一样的内容，这就是深拷贝。
*/
```



移动构造函数

1.理解移动构造函数的作用：在创建对象时，从另一个即将被销毁的临时对象“窃取”资源。

```C++
Object(const Object&& other){
  //浅拷贝，但是要让other放弃资源的访问
}
```



2.掌握移动构造函数的声明和定义，确保资源被正确转移。

3.了解std::move函数和std::forward函数在移动语义中的作用。

```C++
/*
std::move()将一个左值转换成右值引用
std::forward()保留对象的左右值属性，完美转发，根据名字可以看出，当出现中间一层时，会因为参数传递的具名变量变成左值，完美转发就是为了防止这种情况
*/
```



赋值构造函数（赋值运算符重载）

1.理解赋值运算符重载的作用：实现对象之间的赋值操作。

```C++
Object& operator=(const Object& other){
  //先释放本身的资源，然后再深拷贝资源，需要注意自赋值情况！
}
```



2.掌握赋值运算符重载的声明和定义，确保深拷贝或适当的资源管理。

<a id="self"></a>

3.了解自赋值（self-assignment）问题及其解决方案。

```C++
// 如果没有正确处理自赋值情况会导致：
// 在赋值的时候通常会先释放旧内存，再复制新内存，a=a时，会先释放a的内存后，再复制已经释放的内存，导致意想不到的情况发生，一般是程序崩溃或数据损坏
// 自赋值时，ptr已经释放了，是一个悬空指针，然后访问悬空指针。
MyClass& operator=(const MyClass& other) {
    delete ptr;          // 释放自己的内存
    ptr = new int(*other.ptr);  // 试图复制自己已释放的内存
    return *this;
}

```



移动赋值运算符重载

1.理解移动赋值运算符重载的作用：从一个即将被销毁的临时对象“窃取”资源并赋值给当前对象。

```C++
Object& operator=(Object&& other){
  //和移动构造类似，浅拷贝移动资源所有权，最后让other放弃资源的访问
}
```



2.掌握移动赋值运算符重载的声明和定义，确保资源被正确转移并处理自赋值情况。

移动语义

1.理解移动语义的概念及其在资源管理中的作用。

2.能够根据需要使用移动构造函数和移动赋值运算符来提高性能。

回答：

移动语义彻底改变了 C++ 的资源管理方式，其作用主要体现在：

1. **性能提升**：这是最直接的作用。避免了不必要的深拷贝，特别是对于临时对象（右值）和大型容器（如 `std::vector`, `std::string`），性能提升是巨大的。
2. **实现“只移类型”**：有些资源是独一无二，无法或不应该被复制的。例如，`std::unique_ptr`、文件流 (`std::fstream`)、线程 (`std::thread`) 等。移动语义使得这些对象可以作为函数返回值或在容器中被安全地转移，而不是被禁止使用。
3. **使返回值优化 (RVO/NRVO) 更加可靠**：虽然编译器会进行返回值优化，但移动语义提供了一个可靠的、语言级别支持的备选方案。即使 RVO 没有发生，编译器也会自动使用移动操作来避免拷贝，保证了性能。
4. **完美转发**：移动语义与右值引用结合，是实现完美转发（Perfect Forwarding）的基础，使得模板函数能够将参数以原始的值类别（左值或右值）传递给其他函数。

#### 关键机制：右值引用 (`&&`)

移动语义的实现依赖于一种新的引用类型：**右值引用**，语法是 `T&&`。

- **左值**：有持久状态、有名字、可以取地址的表达式。例如变量、函数返回的左值引用。
- **右值**：临时对象、字面量（除了字符串字面量）、返回非引用类型的函数调用、以及通过 `std::move` 转换后的左值。它们即将被销毁。

右值引用 (`T&&`) 主要**绑定到右值**。它延长了临时对象的生命周期，并允许我们去“窃取”其资源。

**`std::move`**： 这是一个定义在 `<utility>` 头文件中的函数。它并**不移动**任何东西。它的作用只有一个：**无条件地将其参数转换为一个右值引用**。它相当于一个静态转换 `static_cast<T&&>(lvalue)`。它告诉编译器：“这个左值对象我愿意放弃它的资源，你可以把它当作一个右值来处理”。

1. 赋值运算符重载时，一定要处理自赋值情况，如果不处理，会发生什么？

   参考：[自赋值](#self)

2. 深入理解移动语义的概念，什么条件下会触发移动语义。

   

3. 拷贝构造函数的参数类型，如果不加引用会怎么样？

   一个对象的引用，推荐加上const，允许接受常量对象，如果不加引用会导致变成值传递，会**拷贝构造**一个临时对象变量传递进去，但是此时正在定义拷贝构造函数，会造成循环调用拷贝构造函数，无限递归调用，最后编译出错。

4. 什么场景下用到移动构造函数？

   场景1:返回局部变量

   ```C++
   std::string makeString() {
       std::string s = "hello world";
       return s;   // 返回时会调用移动构造，而不是拷贝
   }
   ```

   场景2:临时对象的传递

   ```C++
   std::string s = std::string("temporary");
   ```

   场景3:容器的扩容或者插入

   ```C++
   std::vector<std::string> v;
   v.push_back("hello");      // 右值 → 调用移动构造
   std::string str = "world";
   v.push_back(str);          // 左值 → 调用拷贝构造
   v.push_back(std::move(str)); // 强制右值 → 调用移动构造
   ```

   场景4:显式资源转移

   ```C++
   std::unique_ptr<int> p1(new int(42));
   std::unique_ptr<int> p2 = std::move(p1);  // 资源转移，移动构造
   
   ```

   场景5:避免不必要的深拷贝，比如移动构造和移动赋值

   一句话总结：移动构造函数在**涉及临时对象**或**资源转移**时被调用，核心目的是 **性能优化** + **所有权转移**。

5. 掌握什么是深拷贝，什么是浅拷贝。

   参考：[深拷贝和浅拷贝区别](#1)