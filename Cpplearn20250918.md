# 2025年9月18日

## array的使用与理解

### 对于C风格数组

1. 基本概念理解：理解C风格数组是静态分配的连续内存块，其大小在编译时确定，并且没有内置的边界检查。
2. 数组初始化与赋值：掌握如何正确初始化C风格数组，以及如何在数组中使用索引进行赋值和访问。
3. 数组遍历：能够使用循环结构（如for循环）遍历C风格数组，并访问每个元素。
4. 数组与指针：理解数组名在表达式中通常被解释为指向数组首元素的指针，并能够使用指针来遍历和访问数组元素。

### 对于std::array

1. 基本概念理解：理解std::array是C++标准库中的一个固定大小的容器，提供了比C风格数组更多的功能和安全性。
2. 初始化与赋值：掌握如何使用列表初始化、拷贝初始化等方式初始化std::array，以及如何使用at(), operator[]等方法访问和修改元素。
3. 成员函数：了解并能使用std::array提供的成员函数，如size(), empty(), begin(), end()等。
4. 与STL算法结合：理解std::array可以与STL算法无缝结合使用，如std::sort, std::find等。

1. array占用的空间是栈内存还是堆内存？

   栈内存

   ```C++
   struct _LIBCPP_TEMPLATE_VIS array {
     using __trivially_relocatable = __conditional_t<__libcpp_is_trivially_relocatable<_Tp>::value, array, void>;
   
     // types:
     using __self          = array;
     using value_type      = _Tp;
     using reference       = value_type&;
     using const_reference = const value_type&;
     using pointer         = value_type*;
     using const_pointer   = const value_type*;
   #if defined(_LIBCPP_ABI_USE_WRAP_ITER_IN_STD_ARRAY)
     using iterator       = __wrap_iter<pointer>;
     using const_iterator = __wrap_iter<const_pointer>;
   #else
     using iterator       = pointer;
     using const_iterator = const_pointer;
   #endif
     using size_type              = size_t;
     using difference_type        = ptrdiff_t;
     using reverse_iterator       = std::reverse_iterator<iterator>;
     using const_reverse_iterator = std::reverse_iterator<const_iterator>;
   
     _Tp __elems_[_Size];//可以看到是栈内存
     ......
   }
   ```

   

2. 对于固定大小的array，如果越界访问，会发生什么？operator []越界访问和通过at()越界访问有什么区别？

   越界访问会得到未定义的数据，下标操作符访问不会进行越界检查，at（）会进行越界检查，会抛出异常，可以捕获

3. array的实现原理是什么，尝试自己实现一个简单的array？

   

## queue的使用与理解

### 基本概念理解

1. 理解queue是一种容器适配器，它只能在其尾部添加元素（push），在其头部移除元素（pop）。
2. 理解queue提供了对元素的访问功能，但仅限于访问第一个元素（front或back在某些实现中可能也提供，但通常不建议使用back来访问queue的元素）。
3. 理解queue不支持随机访问，即不能通过索引直接访问队列中的元素。

### 基本操作

1. 掌握如何使用push()方法向队列中添加元素。
2. 掌握如何使用pop()方法从队列中移除元素。
3. 掌握如何使用front()或top()（对于某些类似queue的容器，如std::priority_queue使用top()）方法访问队列的第一个元素。
4. 理解empty()和size()方法的使用，分别用于检查队列是否为空和获取队列中元素的数量。

### 迭代器与范围for循环

1. 了解queue不支持迭代器，因此不能使用迭代器或范围for循环直接遍历队列。
2. 理解遍历队列的替代方法，如通过重复调用front()和pop()（但这种方法会修改队列）。

1. 如果queue中没有元素，还调用pop()，会发生什么？

   未定义UB，包括如下情况：

   - 程序崩溃（这是最好的情况，因为它能立即发现问题）。
   - 程序继续运行，但产生错误、怪异的结果或数据损坏。
   - 看起来“正常”运行，但在某个完全无关的时刻突然崩溃。
   - 因系统而异，在某些平台上崩溃，在另一些平台上则不崩溃。

2. queue是实现原理是什么？尝试自己实现一个简单的queue？

## deque的使用与理解

### 基本概念理解

1. 理解deque是一种支持在两端高效插入和删除元素的双端队列。
2. 了解deque不是连续存储的，而是由多个连续存储的块组成，通过指针或引用进行链接。
3. 理解deque提供的接口，如push_front(), pop_front(), push_back(), pop_back(), front(), back(), size(), empty()等。

### 插入与删除操作

1. 掌握如何使用push_front()和push_back()在deque的两端添加元素。
2. 掌握如何使用pop_front()和pop_back()从deque的两端移除元素。
3. 了解这些操作的时间复杂度。

### 访问元素

1. 理解如何使用front()和back()方法分别访问deque的第一个和最后一个元素。
2. 了解如何使用at()方法通过索引访问deque中的元素（尽管这不是deque特有的，但它是STL容器通用的访问方式）。

### 迭代器与范围for循环

1. 了解deque支持迭代器，并能够使用迭代器或范围for循环遍历deque中的元素。

2. 理解迭代器失效的情况，特别是在插入和删除元素时。

   下表总结了 `std::deque` 在各种操作下的迭代器失效情况：

   | 操作                                             | 失效情况                                                     | 解释与例外                                                   |
   | :----------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
   | **在首或尾插入元素 (`push_front`, `push_back`)** | **通常所有迭代器都不会失效**，但**指向的引用会失效**。       | 这是 `deque` 最大的优点。如果插入导致需要分配**新的存储块**，**所有**迭代器**可能**会失效。但这属于实现细节，标准通常保证迭代器不失效。 |
   | **在首或尾删除元素 (`pop_front`, `pop_back`)**   | **指向被删除元素的迭代器和引用肯定失效**。**所有其他迭代器和引用保持有效**。 |                                                              |
   | **在中间插入元素 (`insert`)**                    | **所有迭代器和引用都会失效**。                               | 因为插入点之后的元素都需要移动，这很可能导致重新分配和块的重排。**这是一个非常危险的操作！** |
   | **在中间删除元素 (`erase`)**                     | **所有迭代器和引用都会失效**。                               | 同上，删除点之后的元素需要移动来填补空隙。**同样非常危险！** |
   | **`resize`**                                     | 如果新size > 旧size，且需要分配新块，则**所有迭代器可能失效**。如果新size < 旧size，只有被销毁的那些元素的迭代器和引用失效。 | 行为类似多次 `push_back` 或 `pop_back`。                     |
   | **`clear`**                                      | **所有迭代器和引用都会失效**。                               | 整个容器被清空。                                             |
   | **`swap` (`std::swap` 或成员 `swap`)**           | 迭代器**不会失效**，但**会转而指向另一个容器中的元素**。     | 迭代器、引用和指针在 `swap` 后仍然有效，但它们现在指向的是被交换的 |

3. deque的实现原理是怎么样的？尝试自己实现一个？或者画一个deque的流程图。

4. deque和vector、deque和list，有什么区别？

   <a id="1"></a>

   1. **std::deque vs std::vector**

   这两个容器都支持随机访问（`[]` 运算符），但它们在内部结构和性能特性上有很大不同。

   | 特性                                         | **std::vector**                    | **std::deque** (Double-ended queue)              | 解释与影响                                                   |
   | :------------------------------------------- | :--------------------------------- | :----------------------------------------------- | :----------------------------------------------------------- |
   | **内部结构**                                 | **单一的动态数组**                 | **分段的动态数组（块链）**                       | 这是所有区别的根本原因。                                     |
   | **内存布局**                                 | **完全连续**                       | **分段连续**（逻辑连续，物理不连续）             | `vector` 的数据绝对连续，与C数组兼容；`deque` 是多个固定大小的数组块。 |
   | **头部插入/删除 (`push_front`/`pop_front`)** | **效率低 O(n)**                    | **效率高 O(1)**（摊销时间）                      | 在 `vector` 头部操作需要移动后面所有元素。`deque` 只需操作第一块。 |
   | **尾部插入/删除 (`push_back`/`pop_back`)**   | **效率高 O(1)**（摊销时间）        | **效率高 O(1)**（摊销时间）                      | 两者在尾部操作上都很快。                                     |
   | **中间插入/删除 (`insert`/`erase`)**         | **效率低 O(n)**                    | **效率低 O(n)**                                  | 两者都需要移动元素，但 `vector` 通常更快，因为它的内存是连续的。 |
   | **随机访问 (`[]`, `.at()`)**                 | **极快 O(1)**                      | **快 O(1)**                                      | 都是常数时间，但 `vector` 的连续内存对CPU缓存更友好，通常更快。 |
   | **迭代器类型**                               | **随机访问迭代器**                 | **随机访问迭代器**                               | 两者都支持 `it + n` 等操作。                                 |
   | **迭代器失效**                               | **非常频繁**（容量变化时全部失效） | **较宽松**（首尾操作通常不失效）                 | `vector` 的 `push_back` 可能导致全部重新分配和失效。`deque` 的首尾操作很安全。 |
   | **内存使用**                                 | 通常更少（只有少量额外容量）       | 通常更多（需要维护块映射表和多块的可能空闲空间） | `deque` 有额外的管理开销。                                   |

   **何时选择？**

   - **用 `vector`：** 你需要一个**可动态增长**的**数组**。**绝大多数情况下的默认选择**。适合“只在尾部添加”或“需要绝对最快随机访问”的场景。
   - **用 `deque`：** 你需要一个高效的**队列（FIFO）** 或**双端队列**（既要在头尾操作，又需要随机访问）。当你需要一个“能在头部高效插入的 `vector`”时。

5. **std::deque vs std::list**

这两个容器都在首尾提供了高效的插入删除操作，但它们的底层实现和功能特性截然不同。

| 特性                         | **std::deque** (Double-ended queue) | **std::list** (Doubly-linked list)               | 解释与影响                                                   |
| :--------------------------- | :---------------------------------- | :----------------------------------------------- | :----------------------------------------------------------- |
| **内部结构**                 | **分段的动态数组**                  | **双向链表**                                     | 一个是用数组块，一个是用指针连接节点。                       |
| **内存布局**                 | **分段连续**                        | **完全不连续**                                   | `deque` 的元素在块内是连续的。`list` 的每个元素都在独立的内存节点上。 |
| **任意位置插入/删除**        | **效率低 O(n)**                     | **效率高 O(1)**（已知迭代器位置）                | `list` 只需修改指针，而 `deque` 需要移动大量元素。这是最核心的区别！ |
| **随机访问 (`[]`, `.at()`)** | **支持，快 O(1)**                   | **不支持，极慢 O(n)**                            | `list` 不支持 `[]` 运算符，要访问第n个元素必须从头遍历。     |
| **迭代器类型**               | **随机访问迭代器**                  | **双向迭代器**                                   | `list` 的迭代器只能 `++` 和 `--`，不能 `it + 5`。            |
| **迭代器失效**               | **中间操作使全部失效**              | **极其宽松**（插入不失效，删除只失效被删元素的） | 在 `list` 中插入新元素不会使任何现有迭代器失效（除了被删除的那个）。 |
| **内存使用**                 | 较多（管理开销）                    | **每个元素都有额外开销**（两个指针）             | `list` 为每个元素支付 `prev` 和 `next` 指针的开销，对于小对象来说开销比例很大。 |
| **CPU缓存友好度**            | **高**（块内连续）                  | **低**（内存碎片化）                             | `deque` 的数据更可能位于CPU缓存中，访问更快。`list` 的节点是分 |

**何时选择？**

- **用 `deque`：** 你需要**随机访问**，且主要操作在容器的**首尾**进行。你需要一个“能随机访问的队列”。
- **用 `list`：** 你需要在**容器中间频繁地插入和删除**大量元素，并且**不需要随机访问**。或者你需要**迭代器极度稳定**（插入删除后都不失效）。例如，实现一个LRU缓存。

一图流：

<img src="/Users/joeegin/Desktop/下载/deepseek_mermaid_20250918_6bb6a3.png" alt="deepseek_mermaid_20250918_6bb6a3" style="zoom:25%;" />

## unordered_set、set的使用与理解

### 基本概念理解

1. 理解set是基于红黑树实现的关联容器，支持唯一元素的集合，并自动按键（即元素本身）排序。
2. 理解unordered_set是基于哈希表实现的关联容器，支持唯一元素的集合，但不保证元素的顺序。
3. 了解set和unordered_set提供的接口，如insert(), erase(), find(), count(), size(), empty()等。

### 插入与删除操作

1. 掌握如何使用insert()方法向set或unordered_set中插入元素。
2. 掌握如何使用erase()方法从set或unordered_set中删除元素。
3. 了解erase()方法可以通过迭代器或元素值（对于unordered_set）来指定要删除的元素。

### 查找与访问

1. 理解如何使用find()方法查找set或unordered_set中的元素。
2. 了解set和unordered_set不支持通过索引直接访问元素，因为它们不是基于数组的容器。
3. 了解count()方法可以检查元素是否存在，但由于set和unordered_set保证元素唯一性，count()的返回值总是0或1。

### 遍历

1. 掌握如何使用迭代器遍历set或unordered_set中的所有元素。

   ```C++
   //unordered_set同理
   for(auto it=set.begin();it!=set.end();++it){
   }
   ```

   

2. 了解如何使用范围for循环（C++11及以后）遍历set或unordered_set。

   ```C++
   //unordered_set同理
   for(const auto &i:set){
   }
   ```

   

3. 理解set和unordered_set两者的区别？哪个性能更好？什么场景下使用set？什么场景下使用unordered_set？

   和map类似，set底层是红黑树，unordered_set底层是哈希表，一般情况下哈希表性能更好，但是要看具体情况。

   | 特性                           | **std::set**                               | **std::unordered_set**                 | 解释与影响                                                   |
   | :----------------------------- | :----------------------------------------- | :------------------------------------- | :----------------------------------------------------------- |
   | **底层数据结构**               | 红黑树（平衡BST）                          | 哈希表                                 | 所有区别的根本原因。                                         |
   | **元素顺序**                   | **元素自动排序**（默认升序）               | **元素无序**（顺序取决于哈希函数）     | `set` 的元素总是有序的，`unordered_set` 的顺序是未指定的且可能变动。 |
   | **查找效率 (`find`, `count`)** | **O(log n)**                               | **平均O(1)**，最坏O(n)                 | `unordered_set` 的平均查找速度远快于 `set`。                 |
   | **插入/删除效率**              | **O(log n)**                               | **平均O(1)**，最坏O(n)                 | `unordered_set` 的平均插入/删除速度也更快。                  |
   | **迭代器稳定性**               | **稳定**（除被删除元素外，迭代器始终有效） | **不稳定**（ rehash 后所有迭代器失效） | 长期持有 `unordered_set` 的迭代器是危险的。                  |
   | **迭代器类型**                 | **双向迭代器**（可 `++`、`--`）            | **前向迭代器**（只能 `++`）            | `set` 可以反向遍历，`unordered_set` 只能向前。               |
   | **需要自定义哈希函数**         | 否（只需要 `<` 比较）                      | **是**（如果需要存储自定义类型）       | 让自定义类型作为 `unordered_set` 的键更复杂。                |
   | **内存开销**                   | 较低（每个节点需左右子节点指针）           | 较高（需要维护桶数组和节点指针）       | `unordered_set` 用空间换时间。                               |

   **什么场景下使用 `std::set`？**

   你需要利用其**元素自动排序**的特性时：

   1. **需要按顺序遍历元素或获取有序结果**：例如，需要将公司所有唯一员工ID按顺序打印出来。
   2. **需要按顺序进行范围查询**：例如，找出分数在 [80, 90] 之间的所有学生。利用 `lower_bound()` 和 `upper_bound()` 方法可以高效完成。
   3. **需要快速找到最小值、最大值、中位数附近的值**：因为元素是有序的，`.begin()` 是最小值，`.rbegin()` 是最大值。
   4. **元素类型没有好的哈希函数，但有良好的比较函数**：有时为自定义类型实现 `operator<` 比实现一个分布均匀的哈希函数更容易。
   5. **对最坏情况下的性能有严格要求**：例如，在实时系统或安全关键系统中，你需要稳定的 O(log n) 性能保证，不能接受哈希表最坏情况下的 O(n)。

   ------

   **什么场景下使用 `std::unordered_set`？**

   你主要进行**快速的等值查询（“是否存在”）**，并且**不关心元素顺序**时：

   1. **高速查找是首要目标**：例如，实现一个高速缓存，用于快速判断一个用户名是否已被注册。
   2. **只需要检查元素是否存在，且不需要顺序**：这是 `unordered_set` 最典型的用途。`if (uset.find(key) != uset.end()) ...`。
   3. **存储的元素数量可能非常大**：当 n 很大时，O(1) 和 O(log n) 的差距会非常明显。例如，处理百万级以上数据的去重任务。
   4. **你愿意并且能够为自定义类型提供一个良好的哈希函数**：以确保良好的性能，避免严重的哈希冲突。

4. 判断某个key是否存在时，使用find更好还是使用count更合适？

   使用find更好，1）首先是语义清晰，表达意图明确；2）性能优势，避免不必要的计数；3）可扩展性，find会返回迭代器，方便使用，而count只告诉存在与否。

## list的使用与理解

### 基本概念理解

1. 理解list是一个双向链表，支持常数时间的插入和删除操作，但不支持随机访问。
2. 了解list提供的接口，如push_back(), push_front(), pop_back(), pop_front(), insert(), erase(), size(), empty(), begin(), end(), reverse()等。

### 插入与删除操作

1. 掌握如何使用push_back()和push_front()在list的末尾和开头插入元素。
2. 掌握如何使用pop_back()和pop_front()从list的末尾和开头删除元素。
3. 了解如何使用insert()和erase()在list的任意位置插入和删除元素。

### 遍历

1. 掌握如何使用迭代器遍历list中的所有元素。

   ```C++
   for(auto it=list.begin();it!=list.end();++it){
       
   }
   ```

   

2. 了解如何使用范围for循环（C++11及以后）遍历list（尽管list不支持随机访问迭代器，但范围for循环仍然适用）。

   ```C++
   for(const auto &i:list){
       
   }
   ```

   

### 排序与反转

1. 了解如何使用sort()成员函数对list中的元素进行排序。

2. 了解如何使用reverse()成员函数反转list中元素的顺序。

---

1. list和vector、deque的区别是什么？各自的应用场景是？

   ### 核心区别总结（基于数据结构）

   | 特性                           | **std::vector**            | **std::deque**                           | **std::list**                   |
   | :----------------------------- | :------------------------- | :--------------------------------------- | :------------------------------ |
   | **底层数据结构**               | **单一的动态数组**         | **分段的动态数组（块链）**               | **双向链表**                    |
   | **内存布局**                   | **完全连续**               | **分段连续**                             | **完全不连续**                  |
   | **随机访问 (`[]` 或 `.at()`)** | **极快 O(1)**              | **快 O(1)**                              | **极慢 O(n)**（不支持 `[]`）    |
   | **尾部插入/删除**              | **快 O(1)**（摊销）        | **快 O(1)**                              | **快 O(1)**                     |
   | **头部插入/删除**              | **慢 O(n)**                | **快 O(1)**                              | **快 O(1)**                     |
   | **中间插入/删除**              | **慢 O(n)**                | **慢 O(n)**                              | **极快 O(1)**（已知迭代器位置） |
   | **迭代器类型**                 | **随机访问**               | **随机访问**                             | **双向**                        |
   | **迭代器失效**                 | **频繁**（容量变则全失效） | **中等**（首尾操作安全，中间操作全失效） | **极安全**（只失效被删元素）    |
   | **内存开销**                   | 低（仅少量额外容量）       | 中（需维护块映射表）                     | 高（每个元素含两个指针）        |
   | **CPU缓存友好度**              | **最佳**                   | **很好**（块内连续）                     | **差**（内存碎片化）            |

   使用场景参考：[duque和vector和list区别](#1)

2. std::sort可以对list排序吗？为什么？

   不可以，list不支持随机访问迭代器，std::sort存在随机访问情况（快排操作中的中间基准元素选择），所以不支持，但是可以自己实现sort。

3. 自己实现一个list？